<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hov&#39;s Blog</title>
    <link>https://HauyuChen.github.io/</link>
    <description>Recent content on Hov&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Mon, 14 Aug 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://HauyuChen.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【LeetCode】543. Diameter of Binary Tree</title>
      <link>https://HauyuChen.github.io/post/543-diameter-of-binary-tree/</link>
      <pubDate>Mon, 14 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/543-diameter-of-binary-tree/</guid>
      <description>题目描述：  Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
Example: Given a binary tree
 1 / \ 2 3 / \ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    
    <item>
      <title>【LeetCode】530. Minimum Absolute Difference in BST</title>
      <link>https://HauyuChen.github.io/post/530-minimum-absolute-difference-in-bst/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/530-minimum-absolute-difference-in-bst/</guid>
      <description>题目描述：  Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.
Example:
Input:
 1 \ 3 / 2  Output: 1
Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3). Note: There are at least two nodes in this BST.
 代码实现： /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>【LeetCode】537. Complex Number Multiplication</title>
      <link>https://HauyuChen.github.io/post/537-complex-number-multiplication/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/537-complex-number-multiplication/</guid>
      <description>题目描述：  Given two strings representing two complex numbers.
You need to return a string representing their multiplication. Note i2 = -1 according to the definition.
Example 1:
Input: &amp;ldquo;1+1i&amp;rdquo;, &amp;ldquo;1+1i&amp;rdquo; Output: &amp;ldquo;0+2i&amp;rdquo;
Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.
Example 2: Input: &amp;ldquo;1+-1i&amp;rdquo;, &amp;ldquo;1+-1i&amp;rdquo; Output: &amp;ldquo;0+-2i&amp;rdquo;
Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.</description>
    </item>
    
    <item>
      <title>【LeetCode】541. Reverse String II</title>
      <link>https://HauyuChen.github.io/post/541-reverse-string-ii/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/541-reverse-string-ii/</guid>
      <description>题目描述：  Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.
Example: Input: s = &amp;ldquo;abcdefg&amp;rdquo;, k = 2 Output: &amp;ldquo;bacdfeg&amp;rdquo;</description>
    </item>
    
    <item>
      <title>【机器学习笔记】5. 正则化</title>
      <link>https://HauyuChen.github.io/post/ml-5-regulation/</link>
      <pubDate>Thu, 10 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/ml-5-regulation/</guid>
      <description>作者注：机器学习系列是本人在学习机器学习相关内容时产生的笔记，希望也能对您有所帮助。值得注意的是，作者作为初学者，表述难免有误或不全面，望多批评指正。 如有任何问题，欢迎您随时与我联系：Hauyu.Chen@Gmail.com
版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。

0 前言 前面我们已经提到了线性回归、 逻辑回归的概念。我们通过假设函数去拟合训练集，事实上，在拟合的过程中可能会出现 Overfitting （过拟合）的情况，本文要讲的 Regulation （正则化）是解决 Overfitting 的主要方法之一。

1 拟合问题 在讲解正则化之前，我们需要先了解一下拟合的概念。
还记得房价预测的栗子吗？我们通过房屋面积预测房价，给定一个训练集，我们要用假设函数去拟合这些数据。但其实房屋面积和房价的关系并非线性关系，不能简单地用一条直线来表示。
（1）Underfitting（欠拟合）
下图所示，蓝色直线（假设函数）并不能很好地拟合样本数据，我们将这种情况称为 Underfitting （欠拟合），也可以称为 High bias （高偏差）。
（2）Just Right（刚好拟合）
在原有的假设函数上增加一个二次项，原来的线性函数变成了二次函数，下图为拟合效果，显然，比之前的拟合得更好。蓝色的直线较好地拟合了样本数据，我们可以认为其刚好拟合。
（3）Overfitting（过拟合）
从前两种情况，我们发现增加了新的参数（增加了一个二次项），数据拟合得更好了。现在，我们增加一个三次项和四次项，拟合效果将如下所示，蓝色的线经过了每一个点，而且上下扭曲。这就属于 Overfitting （过拟合），也可称之为 High Variance （高方差）。
你也许会问，我们不是说要让假设函数尽量拟合吗？为什么现在每个数据都拟合了，我们还要去处理它呢？
这是因为，尽管现在的数据拟合得很完美，但它只是和训练样本的拟合，如果我们加入新的测试样本，这样的假设函数往往预测的效果很糟糕。
也就是说，这种模型无法泛化到新的数据，无法预测新的数据。（泛化：指一个假设模型应用到新样本的能力）
同理，在逻辑回归中也存在欠拟合和过拟合的情况。
（1）逻辑回归中的欠拟合
（2）逻辑回归中的刚好拟合
（3）逻辑回归中的过拟合

2 Regulation（正则化） 前面我们提到，我们应该避免出现过拟合的情况，因为这样会使得我们的预测不准确。解决过拟合问题有两种主要的方法：一种是通过减少特征数量；另一种是正则化。
正则化可以保持特征数量不变，通过设置参数的权重来解决过拟合问题。
2.1 正则化线性回归 2.1.1 Cost Function（代价函数） 上面的公式为正则化线性回归的代价函数，蓝色方块为一般线性回归的代价函数，红色方块为正则化项，而 λ 为正则化参数。
正则化参数 λ 需要我们自行选择一个合适的数值，如 λ=1 。
2.1.2 Gradient Descent（梯度下降） 注： θ0 应单独计算，因为不需要惩罚参数 θ0 ，惩罚参数从 θ1 开始。即为正则化操作。</description>
    </item>
    
    <item>
      <title>Java相关特性</title>
      <link>https://HauyuChen.github.io/post/java-trap/</link>
      <pubDate>Tue, 08 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java-trap/</guid>
      <description>Java备忘  float 和 double 不能进行精确运算，因为计算机不能表示所有的小数，采用 BigDecimal 来解决（String）。
 switch 语句不能作用在 long 和 String 上。
 true 、 false 、 null 不是严格意义上的关键字，而是文字常量（literals）。
 float f = 2.5；不正确，因为精度不准确。正确写法：float f = (float)2.5;
 try｛ ｝里面的 return 语句，紧跟着 finally｛ ｝里的代码会在 return 前先执行。</description>
    </item>
    
    <item>
      <title>SQL优化</title>
      <link>https://HauyuChen.github.io/post/sql%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/sql%E4%BC%98%E5%8C%96/</guid>
      <description>SQL 语句优化  尽量选择较小的列； 将 where 中用的比较频繁的字段建立索引； select 子句中避免使用‘ * ’； 避免在索引列上使用运算符、 not 、 in 、 &amp;lt; 、 &amp;gt; 等操作； 当只需要一行数据的时候使用 limit1； 保证表单数据不超过 200w ，适时分割表。</description>
    </item>
    
    <item>
      <title>Elasticsearch操作实例</title>
      <link>https://HauyuChen.github.io/post/es-elasticsearch-manu/</link>
      <pubDate>Sat, 05 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/es-elasticsearch-manu/</guid>
      <description>0 前言 本文通过电商网站商品管理的栗子来熟悉Elasticsearch操作。
栗子中新增了三种品牌的牙膏“高露洁牙膏”、“佳洁士牙膏”、“中华牙膏”，并对这些数据进行增删改查、数据搜索、数据分析等操作。

1 文档增删改查（CRUD） 1.1 新增文档，建立索引 格式：
PUT /index/type/id { //JSON }  实例：新增商品（三种品牌的牙膏信息）。
PUT /ecommerce/product/1 { &amp;quot;name&amp;quot;:&amp;quot;gaolujie yagao&amp;quot;, &amp;quot;desc&amp;quot;:&amp;quot;gaoxiao meibai&amp;quot;, &amp;quot;price&amp;quot;:30, &amp;quot;producer&amp;quot;:&amp;quot;gaolujie producer&amp;quot;, &amp;quot;tags&amp;quot;:[&amp;quot;meibai&amp;quot;,&amp;quot;fangzhu&amp;quot;] } PUT /ecommerce/product/2 { &amp;quot;name&amp;quot;:&amp;quot;jiajieshi yagao&amp;quot;, &amp;quot;desc&amp;quot;:&amp;quot;youxiao fangzhu&amp;quot;, &amp;quot;price&amp;quot;:25, &amp;quot;producer&amp;quot;:&amp;quot;jiajieshi producer&amp;quot;, &amp;quot;tags&amp;quot;:[&amp;quot;fangzhu&amp;quot;] } PUT /ecommerce/product/3 { &amp;quot;name&amp;quot;:&amp;quot;zhonghua yagao&amp;quot;, &amp;quot;desc&amp;quot;:&amp;quot;caoben zhiwu&amp;quot;, &amp;quot;price&amp;quot;:40, &amp;quot;producer&amp;quot;:&amp;quot;zhonghua producer&amp;quot;, &amp;quot;tags&amp;quot;:[&amp;quot;qingxin&amp;quot;] }  
1.2 检索文档 格式：
GET /index/type/id  实例：查询商品。
GET /ecommerce/product/1  
1.3 替换文档 实例：修改商品，将name的“gaolujie yagao”改成“jiaqiangban gaolujie yagao”。</description>
    </item>
    
    <item>
      <title>【机器学习笔记】4. 逻辑回归</title>
      <link>https://HauyuChen.github.io/post/ml-4-logisticregression/</link>
      <pubDate>Thu, 03 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/ml-4-logisticregression/</guid>
      <description>作者注：机器学习系列是本人在学习机器学习相关内容时产生的笔记，希望也能对您有所帮助。值得注意的是，作者作为初学者，表述难免有误或不全面，望多批评指正。 如有任何问题，欢迎您随时与我联系：Hauyu.Chen@Gmail.com
版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。

0 前言 本文要讲的逻辑回归属于分类算法，它是对线性回归的改进。
在处理二分类问题的时候，我们可将所有预测 y 映射成某个值。假设，若该值大于等于0.5，则结果为1；若该值小于0.5，则结果为0。这样，我们就将所有样本分为两类了。
若用线性回归去处理分类问题， y 的值可能远大于1或小于0，这样会造成较大的误差，所以能否让 y 的值处于0到1之间呢？
逻辑回归实现的就是这样的功能，将预测值映射到某个固定的区间，通过决策边界，实现二分类问题。

1 要点 1.1 逻辑函数（Sigmoid函数） 逻辑回归中的逻辑函数其实就是线性回归中的假设函数，只不过在假设函数的基础上进行一个函数映射。
（1）线性回归中的假设函数
（2）逻辑回归中的逻辑函数
逻辑函数对应的图像如下：
可见，逻辑函数将所有预测映射到（0，1）区间。
1.2 Decision Boundary（决策边界） 为了对输出结果进行0和1的分类，我们假设认为 hθ(x) 大于等于0.5，则结果 y=1 ；若 hθ(x) 小于0.5，则结果 y=0 ，即：
根据逻辑函数的图像，有：
即：
所以，决策边界就是将结果分为 y=0 和 y=1 的分界，不同的参数向量 θ ，可对应不同的决策边界。
举个栗子：
这个栗子中，决策边界为 x=5 ，因为在其左边，y=1；在其右边，y=0。
当然，决策边界并非只能是直线，也可能是复杂的曲线。
1.3 Cost Function（代价函数） 上述公式可简化如下：
向量化如下：
1.4 Gradient Descent（梯度下降） 
2 思路 假设，我们要实现邮件的分类（垃圾邮件、非垃圾邮件）
 借助线性回归的思路，我们可以设定假设函数 hθ(x)=θ0*x0+θ1*x1+⋯+θn*xn ，但 hθ(x) 的结果可能在 (−∞,+∞) 之间。 所以，我们通过构造逻辑回归将预测值映射到（0，1）区间，预测值表示该邮件是垃圾邮件的概率。 构造代价函数。 通过梯度下降来最优化特征向量 θ ，求得决策边界。</description>
    </item>
    
    <item>
      <title>JSON相关操作（Java）</title>
      <link>https://HauyuChen.github.io/post/java-json/</link>
      <pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java-json/</guid>
      <description>1 Java中创建JSON import com.google.gson.JsonArray; import com.google.gson.JsonObject; public class CreateJSON { public static void main(String[] args) { JsonObject object = new JsonObject(); object.addProperty(&amp;quot;cat&amp;quot;, &amp;quot;it&amp;quot;); JsonArray array = new JsonArray(); JsonObject lan1 = new JsonObject(); lan1.addProperty(&amp;quot;id&amp;quot;, 1); lan1.addProperty(&amp;quot;name&amp;quot;, &amp;quot;Java&amp;quot;); lan1.addProperty(&amp;quot;ide&amp;quot;, &amp;quot;Eclipse&amp;quot;); array.add(lan1); JsonObject lan2 = new JsonObject(); lan2.addProperty(&amp;quot;id&amp;quot;, 2); lan2.addProperty(&amp;quot;name&amp;quot;, &amp;quot;Swift&amp;quot;); lan2.addProperty(&amp;quot;ide&amp;quot;, &amp;quot;XCode&amp;quot;); array.add(lan2); JsonObject lan3 = new JsonObject(); lan3.addProperty(&amp;quot;id&amp;quot;, 3); lan3.addProperty(&amp;quot;name&amp;quot;, &amp;quot;C#&amp;quot;); lan3.addProperty(&amp;quot;ide&amp;quot;, &amp;quot;Visual Studio&amp;quot;); array.add(lan3); object.add(&amp;quot;languages&amp;quot;, array); object.addProperty(&amp;quot;pop&amp;quot;, true); System.</description>
    </item>
    
    <item>
      <title>XML相关操作（Java）</title>
      <link>https://HauyuChen.github.io/post/java-xml/</link>
      <pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java-xml/</guid>
      <description>1 XML文件创建示例 import java.io.File; import java.io.StringWriter; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import org.w3c.dom.Document; import org.w3c.dom.Element; public class CreateXML { public static void main(String[] args) { try { //DOM DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); Document document = builder.newDocument(); //创建Languages标签 Element root = document.createElement(&amp;quot;Languages&amp;quot;); root.setAttribute(&amp;quot;cat&amp;quot;, &amp;quot;it&amp;quot;); //设置Languages标签的属性 //-----接下来创建Languages标签下的三个子标签lan1、lan2、lan3 //lan1 Element lan1 = document.createElement(&amp;quot;lan&amp;quot;); //lan标签 lan1.setAttribute(&amp;quot;id&amp;quot;, &amp;quot;1&amp;quot;); Element name1 = document.</description>
    </item>
    
    <item>
      <title>【机器学习笔记】3. 线性回归（多变量）</title>
      <link>https://HauyuChen.github.io/post/ml-3-linearregression-multiplevariables/</link>
      <pubDate>Mon, 31 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/ml-3-linearregression-multiplevariables/</guid>
      <description>作者注：机器学习系列是本人在学习机器学习相关内容时产生的笔记，希望也能对您有所帮助。值得注意的是，作者作为初学者，表述难免有误或不全面，望多批评指正。 如有任何问题，欢迎您随时与我联系：Hauyu.Chen@Gmail.com
版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。

0 前言 前面我们已经提到了单变量线性回归，现在讲讲多元线性回归（多变量线性回归）。
在讲解单变量线性回归时，我们引入了房价预测这个栗子，仅通过房屋面积来预测房价。事实上，影响房价的因素有很多，如面积、房间数量、楼层、房龄等等。
现在，我们想在进行房价预测时考虑面积、房间数量、楼层、房龄这几个因素，而不是单单只考虑面积。
显然，单变量线性回归已不再适用，我们可以通过多元线性回归来解决。

1 要点 1.1 多元线性回归模型 这条公式是否很熟悉呢？其实就是在单变量线性回归模型的基础上增加了其它的特征 x2、x3、x4 ··· xn。
为方便计算，我们可以定义 x0=1 ，现在可以将公式转化成如下形式：
令： 特征向量X = [x0,x1,x2, &amp;hellip; ,xn] 参数向量θ = [θ0,θ1,θ2, &amp;hellip; ,θn] X 和 θ 均为 n+1 维向量，有：
最后，假设函数h可简化成以下形式：
1.2 Cost Function（代价函数） 注：多元线性回归的代价函数和单变量线性回归的一致，不过增加了一些新的参数θ3、θ4、θ5···θn。
1.3 Batch Gradient Descent（批量梯度下降） 
2 思路 多元线性回归的思路和单变量线性回归大体一致，只不过我们需要对计算公式做一些微小改变。
同样，还是通过房价预测的栗子来讲解：
 房价取决于多方面的因素，在这里我们考虑面积、房间数量、楼层、房龄这四个因素。所以，我们要搞清楚的就是面积 x1 、房间数量 x2 、楼层 x3 、房龄 x4 对房价 y 的影响。 所以，假设函数为 hθ(x) = θ0 + θ1*x1+ θ2*x2 + θ3*x3+ θ4*x4 。 令 x0=1 ，将假设函数转换成 hθ(x) = θ0*x0 + θ1*x1+ θ2*x2 + θ3*x3+ θ4*x4 。 令特征向量 X=[x0,x1,x2,x3,x4] ,参数向量 θ=[θ0,θ1,θ2,θ3,θ4] ,最终我们的假设函数为 hθ(x)=(θ^T)X 。 问题的核心还是找出合适的参数向量θ，使得我们的预测 hθ(x) 是合理的。 衡量参数向量 θ 是否合适的标准就是代价函数 J(0) ，θ 应使得 J(θ) 尽可能小。</description>
    </item>
    
    <item>
      <title>【机器学习笔记】2. 梯度下降法</title>
      <link>https://HauyuChen.github.io/post/ml-2-gradientdescent/</link>
      <pubDate>Wed, 26 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/ml-2-gradientdescent/</guid>
      <description>作者注：机器学习系列是本人在学习机器学习相关内容时产生的笔记，希望也能对您有所帮助。值得注意的是，作者作为初学者，表述难免有误或不全面，望多批评指正。 如有任何问题，欢迎您随时与我联系：Hauyu.Chen@Gmail.com
版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。

0 前言 上一篇讲到了线性回归，提到了代价函数（Cost Function）的概念，我们知道我们的目标是找到合适的 θ0、θ1 使得代价函数 J(θ0,θ1) 最小。 但是，若漫无目的地设定 θ0、θ1 的值， J(θ0,θ1) 可能会有无数的结果。 那我们要怎么更快地找到 J(θ0,θ1) 的最小值呢？ 本文将介绍一种重要的优化算法，Gradient Descent（梯度下降法）。

1 什么是梯度？ 在讲解梯度下降法之前，我们必须先了解梯度的概念。 梯度是高等数学中的概念，梯度的指向即为函数增长最快的方向。同理，梯度的反方向即为函数下降最快的方向。 现在你知道为什么梯度下降法是优化算法了吧？它能使我们的代价函数下降的最快！

2 原理 下图为代价函数的三维图形，分别以 θ0、θ1 为 X、Y 轴，以 J(θ0,θ1) 为 Z 轴。求解代价函数最小值的过程可看作是寻找“一座座山坡”中的最低点，因为在“山底”时 J(θ0,θ1)最小。
假定我们随机站在某个山坡上，每次往某个方向向下走一步，怎么走才能最快到山底？这也就是梯度下降法所要解决的，沿着梯度方向最小化 J(θ0,θ1) 。
 确定向下一步的步伐大小，称之为 Learning Rate ； 任取 θ0,θ1 （随机站在某个山坡）； 沿着梯度的反方向，走一个步伐大小，更新 θ0、θ1 ，此时 J(θ0,θ1) 变小； 重复步骤3，当下降的高度小于某个定义的值（已经到山底），则停止下降。  
3 算法  优化目标：J(θ0,θ1)
 优化参数：θ0、θ1</description>
    </item>
    
    <item>
      <title>【机器学习笔记】1. 线性回归（单变量）</title>
      <link>https://HauyuChen.github.io/post/ml-1-linearregression-onevariables/</link>
      <pubDate>Fri, 21 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/ml-1-linearregression-onevariables/</guid>
      <description>作者注：机器学习系列是本人在学习机器学习相关内容时产生的笔记，希望也能对您有所帮助。值得注意的是，作者作为初学者，表述难免有误或不全面，望多批评指正。 如有任何问题，欢迎您随时与我联系：Hauyu.Chen@Gmail.com
版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。

0 前言 上一篇提到了监督学习的概念，本文要讲的线性回归就属于监督学习。 本文通过单变量线性回归讲述线性回归思想。值得注意的是，特征x并非只能是一个，也可以有x1、x2、x3···，这就是多特征的问题了（后续会提到）。事实上，单特征和多特征的思想是一样的，本文讨论单特征（只有一个特征x）的情形。

1 要点 1.1 单变量线性回归模型 上述公式（线性函数）为一个最简单的线性回归模型，hθ(x)为我们的假设函数，x是训练集中给的数据，θ0、θ1为未知参数，我们需要计算出合适的θ0、θ1的值。
1.2 Cost Function（代价函数） 上述公式为代价函数的定义，hθ(x)是预测值，x(i)是训练集中第i组数据中的特征，y(i)是训练集中第i组数据中的结果，J(θ0,θ1)表示的是预测值与实际值的误差（方差），误差当然越小越好，所以我们的目标就是最小化Cost Function，即找出合适的θ0、 θ1使得J(θ0,θ1)最小，这样说明数据拟合得最好。

2 思路 我们来引入一个场景，我们想实现房价的预测。
 房价取决于多方面的因素：面积、地段、楼层等等。为方便讨论，我们先不考虑多变量的情况，只考虑单变量。也就是在地段、楼层等因素一致的情况下，面积(x)对房价(y)的影响。 房价预测问题其实就是找出面积x和房价y的关系 hθ(x) = θ0 + θ1*x，即根据面积(x)去预测房价(y)。 所以问题的核心是找出合适的θ0、θ1，使得我们的预测 hθ(x) = θ0 + θ1*x 是合理的。 衡量 θ0、θ1 是否合适的标准就是代价函数J(θ0,θ1)，θ0、θ1应使得J(θ0,θ1)尽可能小。  假定我们已经有了一个训练集，里面包含面积x和对应的房价y。以横轴表示面积x，以竖轴表示房价y，根据训练集可绘制图形如下：
注：图示并非真实数据，只作参考。
线性回归要做的就是通过训练，找出面积x与房价y之间对应的关系（线性函数），通过训练，我们可以得出一条表示 hθ(x) 的直线，这就是我们的预测。

3 结语 现在我们应该知道线性回归的思想了，就是通过训练集去计算出假设函数，通过假设函数可以实现对结果的预测。 假设函数最关键的就是找出未知参数 θ0、θ1 ，因为这两个未知参数决定我们预测是否准确。 未知参数 θ0、θ1 的选择通过代价函数 J(θ0,θ1) 来评定，我们要让 J(θ0,θ1) 尽可能小。 那我们怎么计算 θ0、θ1 的值呢？ 下篇将引入“梯度下降”的方法，通过此方法可更快地计算出 θ0、θ1 的值。</description>
    </item>
    
    <item>
      <title>String相关特性（不定时更新）</title>
      <link>https://HauyuChen.github.io/post/java-string/</link>
      <pubDate>Tue, 18 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java-string/</guid>
      <description>声明：本文是我对Java中String的特性的一些笔记，描述较为简练，有误之处还望指正。
 1.字符串实例化两种方式的区别 String的实例化方式有两种，一种是直接赋值，另一种是通过new关键字实例化。
（1）直接赋值
String str1 = &amp;quot;hello&amp;quot;;  （2）new关键字
String str2 = new String(&amp;quot;hello&amp;quot;);  两种方式都能实例化新的字符串，那我们用哪种方式比较好呢？ 这要先弄清楚他们之间的区别。
 str1是通过直接赋值，str1将直接指向一个存放“hello”的内存空间，因此至占用一个内存空间。 str2是通过new关键字实例化，通过new关键字将开辟一个新的内存空间，赋值后将开辟一个新的内存空间存放str2，也就是说使用new关键字实例化字符串总共开辟了两个内存空间。  综上，使用直接赋值的方法较好，毕竟可以避免占用多余的内存空间。

2.字符串比较“==”与equals的区别 字符串比较是较为常用的功能，Java中主要提供了两种字符串比较方式，“==”和equals，如下：
String str1 = &amp;quot;hello&amp;quot;; String str2 = new String(&amp;quot;hello&amp;quot;); System.out.println(str1==str2); //false System.out.println(str1.equals(str2)); //true  奇怪，明明str1和str2是一样的，为什么“==”会是false呢？
这是因为，“==”比较的是内存单元地址，equals比较的是内容。由前一小节可知，new关键字实例化方式会开辟两个内存空间，str1和str2虽然都是hello，但他们存放的内存空间是不一样的。

3.String内容不可变 假设：
String str = &amp;quot;hello&amp;quot;; str = str + &amp;quot;world!&amp;quot;;  分析：原先str指向的是存放“hello”的内存空间，经过重新赋值，并不会将内存空间的“hello”改成“helloworld!”,而是开辟了新的内存空间存放“helloworld!”，将str重新指向存放“helloworld!”的内存空间。</description>
    </item>
    
    <item>
      <title>【LeetCode】521. Longest Uncommon Subsequence I</title>
      <link>https://HauyuChen.github.io/post/521-longest-uncommon-subsequence-i/</link>
      <pubDate>Sun, 16 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/521-longest-uncommon-subsequence-i/</guid>
      <description>题目描述：  Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.
A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements.</description>
    </item>
    
    <item>
      <title>【LeetCode】520. Detect Capital</title>
      <link>https://HauyuChen.github.io/post/520-detect-capital/</link>
      <pubDate>Sat, 15 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/520-detect-capital/</guid>
      <description>题目描述：  Given a word, you need to judge whether the usage of capitals in it is right or not.
We define the usage of capitals in a word to be right when one of the following cases holds:
All letters in this word are capitals, like &amp;ldquo;USA&amp;rdquo;. All letters in this word are not capitals, like &amp;ldquo;leetcode&amp;rdquo;. Only the first letter in this word is capital if it has more than one letter, like &amp;ldquo;Google&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>【机器学习笔记】0. 什么是机器学习</title>
      <link>https://HauyuChen.github.io/post/ml-0-machinelearning-introduction/</link>
      <pubDate>Tue, 11 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/ml-0-machinelearning-introduction/</guid>
      <description>作者注：机器学习系列是本人在学习机器学习相关内容时产生的笔记，希望也能对您有所帮助。值得注意的是，作者作为初学者，表述难免有误或不全面，望多批评指正。 如有任何问题，欢迎您随时与我联系：Hauyu.Chen@Gmail.com
版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。

0 前言 AI 时代，作为计算机专业的学生，不了解点 AI 相关的知识似乎有点说不过去，尤其是机器学习。 我们一直在说机器学习，但是我们怎么理解机器学习？机器学习解决了什么问题？我们如何将机器学习应用到现实生活中的问题呢？ 本文是机器学习系列的开篇，给出了机器学习的经典定义，并介绍监督学习和无监督学习这两个重要的分支，后续将逐步深入。

1 机器学习的定义 Tom Mitchell 给出了一个关于机器学习的定义，这也是一个被经常引用的定义。
 Tom Mitchell:&amp;ldquo;A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.&amp;rdquo;
 这段话翻译过来就是：对于某类任务T和性能度量P，如果一个计算机程序在T上以P衡量的性能随着经验E而自我完善，那么我们称这个计算机程序在从经验E学习。
举个栗子：AlphaGo下棋
 经验 E = AlphaGo从很多盘棋局获得的经验（学棋）； 任务 T = AlphaGo和对手下棋（下棋）； 性能 P = AlphaGo赢的可能性（赢棋）。</description>
    </item>
    
    <item>
      <title>Eclipse常用快捷键</title>
      <link>https://HauyuChen.github.io/post/eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Sat, 01 Apr 2017 17:54:21 +0800</pubDate>
      
      <guid>https://HauyuChen.github.io/post/eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>Hov：本文记录了一些Eclipse快捷键，其中“必记级别”真的很好用，一定要记住~~
必记级别  Ctrl+1：快速修复，代码红色下划线用它就对了
 Ctrl+D：删除当前整行
 Alt+/：代码补全，例如输入syso后按Alt+/，将其补全成System.out.println();
 Ctrl+/：注释代码（这个很重要）
 Shift+Enter：换行（高级模式，可从代码中间跳至下一行，无需到行尾）
 Ctrl+F11：快速运行项目（其实点小三角还是挺快的，不记也行）
 Ctrl+Shift+F：格式化当前代码（谁用谁牛逼）
  快捷键大全  来源：http://blog.csdn.net/jmyue/article/details/16960199
  Ctrl+Alt+↓：复制当前行到下一行 Ctrl+Alt+↑：复制当前行到上一行 Alt+↓：当前行和下面一行交互位置 Alt+↑：当前行和上面一行交互位置 Alt+←：前一个编辑的页面 Alt+→：下一个编辑的页面 Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性 Shift+Ctrl+Enter 在当前行插入空行 Ctrl+Q 定位到最后编辑的地方 Ctrl+L 定位在某行 Ctrl+M 最大化当前的Edit或View Ctrl+O 快速显示 OutLine Ctrl+T 快速显示当前类的继承结构 Ctrl+W 关闭当前Editer Ctrl+K 参照选中的Word快速定位到下一个 Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示) Ctrl+/ (小键盘) 折叠当前类中的所有代码 Ctrl+×(小键盘) 展开当前类中的所有代码 Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替) Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作) Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这 个功能Idea两年前就有了) Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查) Ctrl+Shift+F4 关闭所有打开的Editer Ctrl+Shift+X 把当前选中的文本全部变味小写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力) Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用) Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候) Alt+Shift+F 把Class中的local变量变为field 变量 (比较实用的功能) Alt+Shift+I 合并变量(可能这样说有点不妥Inline) Alt+Shift+V 移动函数和变量(不怎么常用) Alt+Shift+Z 重构的后悔药(Undo)  注：下面这篇文章有动画讲解，推荐一下：）</description>
    </item>
    
    <item>
      <title>【LeetCode】506. Relative Ranks</title>
      <link>https://HauyuChen.github.io/post/506-relative-ranks/</link>
      <pubDate>Tue, 21 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/506-relative-ranks/</guid>
      <description>题目描述：  Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: &amp;ldquo;Gold Medal&amp;rdquo;, &amp;ldquo;Silver Medal&amp;rdquo; and &amp;ldquo;Bronze Medal&amp;rdquo;.
Example 1: Input: [5, 4, 3, 2, 1] Output: [&amp;ldquo;Gold Medal&amp;rdquo;, &amp;ldquo;Silver Medal&amp;rdquo;, &amp;ldquo;Bronze Medal&amp;rdquo;, &amp;ldquo;4&amp;rdquo;, &amp;ldquo;5&amp;rdquo;]
Explanation: The first three athletes got the top three highest scores, so they got &amp;ldquo;Gold Medal&amp;rdquo;, &amp;ldquo;Silver Medal&amp;rdquo; and &amp;ldquo;Bronze Medal&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>【LeetCode】496. Next Greater Element I</title>
      <link>https://HauyuChen.github.io/post/496-next-greater-element-i/</link>
      <pubDate>Mon, 20 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/496-next-greater-element-i/</guid>
      <description>题目描述：  You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1&amp;rsquo;s elements in the corresponding places of nums2.
The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.
Example 1: Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</description>
    </item>
    
    <item>
      <title>【LeetCode】504. Base 7</title>
      <link>https://HauyuChen.github.io/post/504-base-7/</link>
      <pubDate>Mon, 20 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/504-base-7/</guid>
      <description> 题目描述：  Given an integer, return its base 7 string representation.
Example 1: Input: 100 Output: &amp;ldquo;202&amp;rdquo;
Example 2: Input: -7 Output: &amp;ldquo;-10&amp;rdquo;
Note: The input will be in range of [-1e7, 1e7].
 代码实现： class Solution { public: string convertToBase7(int num) { string str=&amp;quot;&amp;quot;; int nega=0; if(num&amp;lt;0){ nega = 1; num = abs(num); } while(num/7){ str+=to_string(num%7); num/=7; } str+=to_string(num%7); if(nega){ str+=&amp;quot;-&amp;quot;; } reverse(str.begin(),str.end()); return str; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】492. Construct the Rectangle</title>
      <link>https://HauyuChen.github.io/post/492-construct-the-rectangle/</link>
      <pubDate>Sun, 19 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/492-construct-the-rectangle/</guid>
      <description>题目描述：  For a web developer, it is very important to know how to design a web page&amp;rsquo;s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:
 The area of the rectangular web page you designed must equal to the given target area.
 The width W should not be larger than the length L, which means L &amp;gt;= W.</description>
    </item>
    
    <item>
      <title>【LeetCode】485. Max Consecutive Ones</title>
      <link>https://HauyuChen.github.io/post/485-max-consecutive-ones/</link>
      <pubDate>Sat, 18 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/485-max-consecutive-ones/</guid>
      <description>题目描述：  Given a binary array, find the maximum number of consecutive 1s in this array.
Example 1: Input: [1,1,0,1,1,1] Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.
Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000
 代码实现： class Solution { public: int findMaxConsecutiveOnes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int cnt=0,max=0; for(int num:nums){ if(num==1){ cnt++; }else{ cnt=0; } max = max&amp;gt;cnt?</description>
    </item>
    
    <item>
      <title>【LeetCode】476. Number Complement</title>
      <link>https://HauyuChen.github.io/post/476-number-complement/</link>
      <pubDate>Fri, 17 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/476-number-complement/</guid>
      <description>题目描述：  Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.
Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation.
Example 1: Input: 5 Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010.</description>
    </item>
    
    <item>
      <title>【LeetCode】455. Assign Cookies</title>
      <link>https://HauyuChen.github.io/post/455-assign-cookies/</link>
      <pubDate>Thu, 16 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/455-assign-cookies/</guid>
      <description>题目描述：  Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &amp;gt;= gi, we can assign the cookie j to the child i, and the child i will be content.</description>
    </item>
    
    <item>
      <title>【LeetCode】461. Hamming Distance</title>
      <link>https://HauyuChen.github.io/post/461-hamming-distance/</link>
      <pubDate>Thu, 16 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/461-hamming-distance/</guid>
      <description>题目描述：  The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Given two integers x and y, calculate the Hamming distance.
Note: 0 ≤ x, y &amp;lt; 231.
Example:
Input: x = 1, y = 4
Output: 2
Explanation:
1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑  The above arrows point to positions where the corresponding bits are different.</description>
    </item>
    
    <item>
      <title>【LeetCode】463. Island Perimeter</title>
      <link>https://HauyuChen.github.io/post/463-island-perimeter/</link>
      <pubDate>Thu, 16 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/463-island-perimeter/</guid>
      <description>题目描述：  You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn&amp;rsquo;t have &amp;ldquo;lakes&amp;rdquo; (water inside that isn&amp;rsquo;t connected to the water around the island). One cell is a square with side length 1.</description>
    </item>
    
    <item>
      <title>【LeetCode】453. Minimum Moves to Equal Array Elements</title>
      <link>https://HauyuChen.github.io/post/453-minimum-moves-to-equal-array-elements/</link>
      <pubDate>Wed, 15 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/453-minimum-moves-to-equal-array-elements/</guid>
      <description>题目描述：  Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.
Example:
Input: [1,2,3]
Output: 3
Explanation: Only three moves are needed (remember each move increments two elements): [1,2,3] =&amp;gt; [2,3,3] =&amp;gt; [3,4,3] =&amp;gt; [4,4,4]
 代码实现： class Solution { public: int minMoves(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int min=INT_MAX; int sum=0; for(int num:nums){ min=min&amp;lt;num?</description>
    </item>
    
    <item>
      <title>【LeetCode】448. Find All Numbers Disappeared in an Array</title>
      <link>https://HauyuChen.github.io/post/448-find-all-numbers-disappeared-in-an-array/</link>
      <pubDate>Tue, 21 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/448-find-all-numbers-disappeared-in-an-array/</guid>
      <description>题目描述：  Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements of [1, n] inclusive that do not appear in this array.
Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.
Example:
Input: [4,3,2,7,8,2,3,1]
Output: [5,6]</description>
    </item>
    
    <item>
      <title>【LeetCode】447. Number of Boomerangs</title>
      <link>https://HauyuChen.github.io/post/447-number-of-boomerangs/</link>
      <pubDate>Mon, 20 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/447-number-of-boomerangs/</guid>
      <description>题目描述：  Given n points in the plane that are all pairwise distinct, a &amp;ldquo;boomerang&amp;rdquo; is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).
Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range -10000, 10000.</description>
    </item>
    
    <item>
      <title>【LeetCode】414. Third Maximum Number</title>
      <link>https://HauyuChen.github.io/post/414-third-maximum-number/</link>
      <pubDate>Sun, 19 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/414-third-maximum-number/</guid>
      <description>题目描述：  Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).
Example 1: Input: [3, 2, 1] Output: 1
Explanation: The third maximum is 1.
Example 2: Input: [1, 2] Output: 2
Explanation: The third maximum does not exist, so the maximum (2) is returned instead.
Example 3: Input: [2, 2, 3, 1] Output: 1</description>
    </item>
    
    <item>
      <title>【LeetCode】415. Add Strings</title>
      <link>https://HauyuChen.github.io/post/415-add-strings/</link>
      <pubDate>Sun, 19 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/415-add-strings/</guid>
      <description>题目描述：  Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.
Note: The length of both num1 and num2 is &amp;lt; 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly.
 代码实现： class Solution { public: string addStrings(string num1, string num2) { string str; int index1=num1.</description>
    </item>
    
    <item>
      <title>【LeetCode】412. Fizz Buzz</title>
      <link>https://HauyuChen.github.io/post/412-fizz-buzz/</link>
      <pubDate>Sat, 18 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/412-fizz-buzz/</guid>
      <description>题目描述：  Write a program that outputs the string representation of numbers from 1 to n.
But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.
Example:
n = 15,
Return: [ &amp;ldquo;1&amp;rdquo;, &amp;ldquo;2&amp;rdquo;, &amp;ldquo;Fizz&amp;rdquo;, &amp;ldquo;4&amp;rdquo;, &amp;ldquo;Buzz&amp;rdquo;, &amp;ldquo;Fizz&amp;rdquo;, &amp;ldquo;7&amp;rdquo;, &amp;ldquo;8&amp;rdquo;, &amp;ldquo;Fizz&amp;rdquo;, &amp;ldquo;Buzz&amp;rdquo;, &amp;ldquo;11&amp;rdquo;, &amp;ldquo;Fizz&amp;rdquo;, &amp;ldquo;13&amp;rdquo;, &amp;ldquo;14&amp;rdquo;, &amp;ldquo;FizzBuzz&amp;rdquo; ]</description>
    </item>
    
    <item>
      <title>【LeetCode】409. Longest Palindrome</title>
      <link>https://HauyuChen.github.io/post/409-longest-palindrome/</link>
      <pubDate>Fri, 17 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/409-longest-palindrome/</guid>
      <description>题目描述：  Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.
This is case sensitive, for example &amp;ldquo;Aa&amp;rdquo; is not considered a palindrome here.
Note: Assume the length of given string will not exceed 1,010.
Example:
Input: &amp;ldquo;abccccdd&amp;rdquo;
Output: 7
Explanation: One longest palindrome that can be built is &amp;ldquo;dccaccd&amp;rdquo;, whose length is 7.</description>
    </item>
    
    <item>
      <title>【LeetCode】401. Binary Watch</title>
      <link>https://HauyuChen.github.io/post/401-binary-watch/</link>
      <pubDate>Thu, 16 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/401-binary-watch/</guid>
      <description>题目描述：  A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).
Each LED represents a zero or one, with the least significant bit on the right.
For example, the above binary watch reads &amp;ldquo;3:25&amp;rdquo;.
Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</description>
    </item>
    
    <item>
      <title>【LeetCode】404. Sum of Left Leaves</title>
      <link>https://HauyuChen.github.io/post/404-sum-of-left-leaves/</link>
      <pubDate>Thu, 16 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/404-sum-of-left-leaves/</guid>
      <description> 题目描述：  Find the sum of all left leaves in a given binary tree.
Example:
 3 / \ 9 20 / \ 15 7  There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
 代码实现： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int sumOfLeftLeaves(TreeNode* root) { if(root==nullptr){ return 0; } int sum=0; if(root-&amp;gt;left){ if(root-&amp;gt;left-&amp;gt;left==nullptr &amp;amp;&amp;amp; root-&amp;gt;left-&amp;gt;right==nullptr){ sum+=root-&amp;gt;left-&amp;gt;val; }else{ sum+=sumOfLeftLeaves(root-&amp;gt;left); } } if(root-&amp;gt;right){ sum+=sumOfLeftLeaves(root-&amp;gt;right); } return sum; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】389. Find the Difference</title>
      <link>https://HauyuChen.github.io/post/389-find-the-difference/</link>
      <pubDate>Wed, 15 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/389-find-the-difference/</guid>
      <description>题目描述：  Given two strings s and t which consist of only lowercase letters.
String t is generated by random shuffling string s and then add one more letter at a random position.
Find the letter that was added in t.
Example:
Input: s = &amp;ldquo;abcd&amp;rdquo; t = &amp;ldquo;abcde&amp;rdquo;
Output: e
Explanation: &amp;lsquo;e&amp;rsquo; is the letter that was added.
 代码实现： class Solution { public: char findTheDifference(string s, string t) { char ch = t[0]; for(int i=1;i&amp;lt;t.</description>
    </item>
    
    <item>
      <title>【LeetCode】387. First Unique Character in a String</title>
      <link>https://HauyuChen.github.io/post/387-first-unique-character-in-a-string/</link>
      <pubDate>Tue, 14 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/387-first-unique-character-in-a-string/</guid>
      <description> 题目描述：  Given a string, find the first non-repeating character in it and return it&amp;rsquo;s index. If it doesn&amp;rsquo;t exist, return -1.
Examples:
s = &amp;ldquo;leetcode&amp;rdquo; return 0.
s = &amp;ldquo;loveleetcode&amp;rdquo;, return 2.
Note: You may assume the string contain only lowercase letters.
 代码实现： class Solution { public: int firstUniqChar(string s) { int arr[26]; for(int i=0;i&amp;lt;26;++i){ arr[i]=0; } for(int i=0;i&amp;lt;s.size();++i){ ++arr[s[i]-&#39;a&#39;]; } for(int i=0;i&amp;lt;s.size();++i){ if(arr[s[i]-&#39;a&#39;]==1){ return i; } } return -1; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】371. Sum of Two Integers</title>
      <link>https://HauyuChen.github.io/post/371-sum-of-two-integers/</link>
      <pubDate>Mon, 13 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/371-sum-of-two-integers/</guid>
      <description> 题目描述：  Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
Example: Given a = 1 and b = 2, return 3.
 代码实现： class Solution { public: int getSum(int a, int b) { return b==0?a:getSum(a^b,(a&amp;amp;b)&amp;lt;&amp;lt;1); } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】383. Ransom Note</title>
      <link>https://HauyuChen.github.io/post/383-ransom-note/</link>
      <pubDate>Mon, 13 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/383-ransom-note/</guid>
      <description>题目描述：  Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.
Each letter in the magazine string can only be used once in your ransom note.
Note: You may assume that both strings contain only lowercase letters.
 canConstruct(&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;) -&amp;gt; false canConstruct(&amp;ldquo;aa&amp;rdquo;, &amp;ldquo;ab&amp;rdquo;) -&amp;gt; false canConstruct(&amp;ldquo;aa&amp;rdquo;, &amp;ldquo;aab&amp;rdquo;) -&amp;gt; true   代码实现： class Solution { public: bool canConstruct(string ransomNote, string magazine) { if(magazine.</description>
    </item>
    
    <item>
      <title>【LeetCode】349. Intersection of Two Arrays</title>
      <link>https://HauyuChen.github.io/post/349-intersection-of-two-arrays/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/349-intersection-of-two-arrays/</guid>
      <description> 题目描述：  Given two arrays, write a function to compute their intersection.
Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].
Note: Each element in the result must be unique. The result can be in any order.
 代码实现： class Solution { public: vector&amp;lt;int&amp;gt; intersection(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { unordered_set&amp;lt;int&amp;gt; s; vector&amp;lt;int&amp;gt; ret; for(int num1:nums1){ if(s.count(num1)==0){ s.insert(num1); } } for(int num2:nums2){ if(s.count(num2)){ ret.push_back(num2); s.erase(num2); } } return ret; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】350. Intersection of Two Arrays II</title>
      <link>https://HauyuChen.github.io/post/350-intersection-of-two-arrays-ii/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/350-intersection-of-two-arrays-ii/</guid>
      <description>题目描述：  Given two arrays, write a function to compute their intersection.
Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].
Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1&amp;rsquo;s size is small compared to nums2&amp;rsquo;s size?</description>
    </item>
    
    <item>
      <title>【LeetCode】344. Reverse String</title>
      <link>https://HauyuChen.github.io/post/344-reverse-string/</link>
      <pubDate>Fri, 13 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/344-reverse-string/</guid>
      <description> 题目描述：  Write a function that takes a string as input and returns the string reversed.
Example: Given s = &amp;ldquo;hello&amp;rdquo;, return &amp;ldquo;olleh&amp;rdquo;.
 代码实现： class Solution { public: string reverseString(string s) { reverse(s.begin(),s.end()); return s; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】326. Power of Three</title>
      <link>https://HauyuChen.github.io/post/326-power-of-three/</link>
      <pubDate>Thu, 12 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/326-power-of-three/</guid>
      <description> 题目描述：  Given an integer, write a function to determine if it is a power of three.
Follow up: Could you do it without using any loop / recursion?
 代码实现： class Solution { public: bool isPowerOfThree(int n) { if(n&amp;lt;=0){ return false; } while(n%3==0){ n/=3; } if(n==1){ return true; } return false; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】338. Counting Bits</title>
      <link>https://HauyuChen.github.io/post/338-counting-bits/</link>
      <pubDate>Thu, 12 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/338-counting-bits/</guid>
      <description>题目描述：  Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;rsquo;s in their binary representation and return them as an array.
Example: For num = 5 you should return [0,1,1,2,1,2].
Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?</description>
    </item>
    
    <item>
      <title>【LeetCode】268. Missing Number</title>
      <link>https://HauyuChen.github.io/post/268-missing-number/</link>
      <pubDate>Wed, 11 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/268-missing-number/</guid>
      <description>题目描述：  Given an array containing n distinct numbers taken from 0, 1, 2, &amp;hellip;, n, find the one that is missing from the array.
For example, Given nums = [0, 1, 3] return 2.
Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
 代码实现： class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int sum=0; int realsum=0; bool flag=false; for(int i=0;i&amp;lt;nums.</description>
    </item>
    
    <item>
      <title>【LeetCode】283. Move Zeroes</title>
      <link>https://HauyuChen.github.io/post/283-move-zeroes/</link>
      <pubDate>Wed, 11 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/283-move-zeroes/</guid>
      <description>题目描述：  Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
Note: You must do this in-place without making a copy of the array. Minimize the total number of operations.
 代码实现： class Solution { public: void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int index=0; for(int i=0;i&amp;lt;nums.</description>
    </item>
    
    <item>
      <title>【LeetCode】292. Nim Game</title>
      <link>https://HauyuChen.github.io/post/292-nim-game/</link>
      <pubDate>Wed, 11 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/292-nim-game/</guid>
      <description>题目描述：  You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.
Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</description>
    </item>
    
    <item>
      <title>【LeetCode】258. Add Digits</title>
      <link>https://HauyuChen.github.io/post/258-add-digits/</link>
      <pubDate>Tue, 10 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/258-add-digits/</guid>
      <description> 题目描述：  Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
For example:
Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.
Follow up: Could you do it without any loop/recursion in O(1) runtime?
 代码实现： class Solution { public: int addDigits(int num) { return 1+(num-1)%9; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】263. Ugly Number</title>
      <link>https://HauyuChen.github.io/post/263-ugly-number/</link>
      <pubDate>Tue, 10 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/263-ugly-number/</guid>
      <description>题目描述：  Write a program to check whether a given number is an ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.
Note that 1 is typically treated as an ugly number.
 代码实现： class Solution { public: bool isUgly(int num) { if(num&amp;lt;=0){ return false; } while(num%2==0){ num/=2; } while(num%3==0){ num/=3; } while(num%5==0){ num/=5; } return num==1?</description>
    </item>
    
    <item>
      <title>【LeetCode】231. Power of Two</title>
      <link>https://HauyuChen.github.io/post/231-power-of-two/</link>
      <pubDate>Mon, 09 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/231-power-of-two/</guid>
      <description> 题目描述：  Given an integer, write a function to determine if it is a power of two.
 代码实现： class Solution { public: bool isPowerOfTwo(int n) { int flag=0; if(n&amp;lt;=0){ return false; } while(n&amp;gt;0){ if(n&amp;amp;1==1){ if(flag==1){ return false; } flag=1; } n=n&amp;gt;&amp;gt;1; } return true; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】237. Delete Node in a Linked List</title>
      <link>https://HauyuChen.github.io/post/237-delete-node-in-a-linked-list/</link>
      <pubDate>Mon, 09 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/237-delete-node-in-a-linked-list/</guid>
      <description> 题目描述：  Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.
Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.
 代码实现： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { auto next = node-&amp;gt;next; *node = *next; delete next; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】242. Valid Anagram</title>
      <link>https://HauyuChen.github.io/post/242-valid-anagram/</link>
      <pubDate>Mon, 09 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/242-valid-anagram/</guid>
      <description>题目描述：  Given two strings s and t, write a function to determine if t is an anagram of s.
For example, s = &amp;ldquo;anagram&amp;rdquo;, t = &amp;ldquo;nagaram&amp;rdquo;, return true. s = &amp;ldquo;rat&amp;rdquo;, t = &amp;ldquo;car&amp;rdquo;, return false.
Note: You may assume the string contains only lowercase alphabets.
Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?
 代码实现： class Solution { public: bool isAnagram(string s, string t) { if(s.</description>
    </item>
    
    <item>
      <title>【LeetCode】226. Invert Binary Tree</title>
      <link>https://HauyuChen.github.io/post/226-invert-binary-tree/</link>
      <pubDate>Sun, 08 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/226-invert-binary-tree/</guid>
      <description>题目描述：  Invert a binary tree.
 4 / \ 2 7 / \ / \ 1 3 6 9 to 4 / \ 7 2 / \ / \ 9 6 3 1  Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</description>
    </item>
    
    <item>
      <title>【LeetCode】206. Reverse Linked List</title>
      <link>https://HauyuChen.github.io/post/206-reverse-linked-list/</link>
      <pubDate>Sat, 07 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/206-reverse-linked-list/</guid>
      <description> 题目描述：  Reverse a singly linked list.
 代码实现： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* pPre=nullptr; ListNode* pNode=head; ListNode* pRet=nullptr; while(pNode!=nullptr){ ListNode* pNext=pNode-&amp;gt;next; if(pNext==nullptr){ pRet=pNode; } pNode-&amp;gt;next=pPre; pPre=pNode; pNode=pNext; } return pRet; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】217. Contains Duplicate</title>
      <link>https://HauyuChen.github.io/post/217-contains-duplicate/</link>
      <pubDate>Sat, 07 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/217-contains-duplicate/</guid>
      <description> 题目描述：  Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
 代码实现： class Solution { public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_set&amp;lt;int&amp;gt; set; for(int num:nums){ if(set.count(num)){ return true; } set.insert(num); } return false; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】191. Number of 1 Bits</title>
      <link>https://HauyuChen.github.io/post/191-number-of-1-bits/</link>
      <pubDate>Wed, 24 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/191-number-of-1-bits/</guid>
      <description> 题目描述：  Write a function that takes an unsigned integer and returns the number of ’1&amp;rsquo; bits it has (also known as the Hamming weight).
For example, the 32-bit integer ’11&amp;rsquo; has binary representation 00000000000000000000000000001011, so the function should return 3.
 代码实现： class Solution { public: int hammingWeight(uint32_t n) { int sum=0; while(n&amp;gt;0){ if(n&amp;amp;1==1){ sum++; } n=n&amp;gt;&amp;gt;1; } return sum; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】202. Happy Number</title>
      <link>https://HauyuChen.github.io/post/202-happy-number/</link>
      <pubDate>Wed, 24 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/202-happy-number/</guid>
      <description>题目描述：  Write an algorithm to determine if a number is &amp;ldquo;happy&amp;rdquo;.
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
    <item>
      <title>【LeetCode】171. Excel Sheet Column Number</title>
      <link>https://HauyuChen.github.io/post/171-excel-sheet-column-number/</link>
      <pubDate>Tue, 23 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/171-excel-sheet-column-number/</guid>
      <description> 题目描述：  Related to question Excel Sheet Column Title
Given a column title as appear in an Excel sheet, return its corresponding column number.
For example:
A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28   代码实现： class Solution { public: int titleToNumber(string s) { int sum=0; for(int i=0;i&amp;lt;s.length();i++){ sum = sum*26+(s[i]-&#39;A&#39;+1); } return sum; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】167. Two Sum II - Input array is sorted</title>
      <link>https://HauyuChen.github.io/post/167-two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Sat, 20 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/167-two-sum-ii-input-array-is-sorted/</guid>
      <description>题目描述：  Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution and you may not use the same element twice.</description>
    </item>
    
    <item>
      <title>【LeetCode】169. Majority Element</title>
      <link>https://HauyuChen.github.io/post/169-majority-element/</link>
      <pubDate>Sat, 20 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/169-majority-element/</guid>
      <description> 题目描述：  Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
 代码实现： class Solution { public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int major=nums[0]; int cnt=1; for(int num:nums){ if(num==major){ ++cnt; }else{ --cnt; } if(cnt==0){ ++cnt; major = num; } } return major; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】121. Best Time to Buy and Sell Stock</title>
      <link>https://HauyuChen.github.io/post/121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/121-best-time-to-buy-and-sell-stock/</guid>
      <description>题目描述：  Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5
max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: Input: [7, 6, 4, 3, 1] Output: 0</description>
    </item>
    
    <item>
      <title>【LeetCode】122. Best Time to Buy and Sell Stock II</title>
      <link>https://HauyuChen.github.io/post/122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>题目描述：  Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>【LeetCode】136. Single Number</title>
      <link>https://HauyuChen.github.io/post/136-single-number/</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/136-single-number/</guid>
      <description> 题目描述：  Given an array of integers, every element appears twice except for one. Find that single one.
Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
 代码实现： class Solution { public: int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ret = 0; for(int num:nums){ ret^=num; } return ret; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】104. Maximum Depth of Binary Tree</title>
      <link>https://HauyuChen.github.io/post/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Mon, 15 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/104-maximum-depth-of-binary-tree/</guid>
      <description>题目描述：  Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
 代码实现： /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int maxDepth(TreeNode *root) { int Ldepth=0,Rdepth=0; if(root==NULL){ return 0; } if(root-&amp;gt;left==NULL &amp;amp;&amp;amp; root-&amp;gt;right==NULL){ return 1; } Ldepth=maxDepth(root-&amp;gt;left); Rdepth=maxDepth(root-&amp;gt;right); return 1+(Ldepth&amp;gt;Rdepth?</description>
    </item>
    
    <item>
      <title>【LeetCode】100. Same Tree</title>
      <link>https://HauyuChen.github.io/post/100-same-tree/</link>
      <pubDate>Sun, 14 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/100-same-tree/</guid>
      <description>题目描述：  Given two binary trees, write a function to check if they are equal or not.
Two binary trees are considered equal if they are structurally identical and the nodes have the same value.
 代码实现： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p==nullptr &amp;amp;&amp;amp; q==nullptr){ return true; } else if(p==nullptr || q==nullptr){ return false; } if(p-&amp;gt;val!</description>
    </item>
    
    <item>
      <title>【LeetCode】70. Climbing Stairs</title>
      <link>https://HauyuChen.github.io/post/070-climbing-stairs/</link>
      <pubDate>Sun, 14 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/070-climbing-stairs/</guid>
      <description> 题目描述：  You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
 思路：  这题本质上是斐波那契数列问题。这里采用数组暂存已有结果，以时间换空间，减少递归带来的重复计算。
 代码实现： class Solution { public: int climbStairs(int n) { int f[n+1]; f[0]=1; f[1]=1; for(int i=2;i&amp;lt;=n;++i){ f[i]=f[i-1]+f[i-2]; } return f[n]; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】69. Sqrt(x)</title>
      <link>https://HauyuChen.github.io/post/069-sqrtx/</link>
      <pubDate>Sat, 13 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/069-sqrtx/</guid>
      <description> 题目描述：  Implement int sqrt(int x).
Compute and return the square root of x.
 代码实现： class Solution { public: int mySqrt(int x) { if(x==0){ return 0; } int low=1,high=x; int mid; while(1){ mid = (low+high)/2; if(mid&amp;gt;x/mid){ high = mid-1; } else{ if((mid+1)&amp;gt;(x/(mid+1))){ return mid; } low = mid+1; } } } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】13. Roman to Integer</title>
      <link>https://HauyuChen.github.io/post/013-roman-to-integer/</link>
      <pubDate>Fri, 12 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/013-roman-to-integer/</guid>
      <description> 题目描述：  Given a roman numeral, convert it to an integer.
Input is guaranteed to be within the range from 1 to 3999.
 我的思路：  这是一道将罗马数字转换成整数的题目。搞清楚罗马数字的表示特点即可。
参见维基百科：罗马数字
 代码实现： class Solution { public: int romanToInt(string s) { unordered_map&amp;lt;char,int&amp;gt; hm; hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;I&#39;,1)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;V&#39;,5)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;X&#39;,10)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;L&#39;,50)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;C&#39;,100)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;D&#39;,500)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;M&#39;,1000)); int sum=hm[s[s.size()-1]]; for(int i=s.size()-1;i&amp;gt;0;--i){ if(hm[s[i]]&amp;gt;hm[s[i-1]]){ sum-=hm[s[i-1]]; }else{ sum+=hm[s[i-1]]; } } return sum; } };  </description>
    </item>
    
    <item>
      <title>【LeetCode】21. Merge Two Sorted Lists</title>
      <link>https://HauyuChen.github.io/post/021-merge-two-sorted-lists/</link>
      <pubDate>Fri, 12 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/021-merge-two-sorted-lists/</guid>
      <description>题目描述：  Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
 我的思路：   通过一个指针newhead指示新的链表头部，比较链表l1和链表l2的第一个结点。 若l1的第一个节点比l2小，则将其尾插进新链表，移动指针l1-&amp;gt;next；若l2的第一个节点比l1小，同理。 递归得解。   代码实现： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1==nullptr&amp;amp;&amp;amp;l2==nullptr) return nullptr; if(l1==nullptr || l2==nullptr) return (l1==nullptr)?</description>
    </item>
    
    <item>
      <title>【LeetCode】53. Maximum Subarray</title>
      <link>https://HauyuChen.github.io/post/053-maximum-subarray/</link>
      <pubDate>Fri, 12 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/053-maximum-subarray/</guid>
      <description> 题目描述：  Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6.
 我的思路：  用sum保存连续序列之和，用max表示最大值，一次遍历即可，时间复杂度O(n)。
 sum&amp;lt;0,则舍弃前面的数 sum&amp;gt;max,则更新最大值max   代码实现： int maxSubArray(int* nums, int numsSize) { int sum=0; int max=INT_MIN; for(int i=0;i&amp;lt;numsSize;i++){ sum+=nums[i]; if(sum&amp;gt;max){ max = sum; } if(sum&amp;lt;0){ sum = 0; } } return max; }  </description>
    </item>
    
    <item>
      <title>【LeetCode】1. Two Sum</title>
      <link>https://HauyuChen.github.io/post/001-two-sum/</link>
      <pubDate>Thu, 11 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/001-two-sum/</guid>
      <description>题目描述：  Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example: Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].
 我的思路：   先用map存储每个元素对应的原始下标，方便后续查找特定元素。 从头开始查找符合条件的结果，用target减去nums[i]，得到两数之差t，在map中寻找是否存在t且元素t的索引不等于i,若是则为最终结果，否则继续查找nums[i+1]。   代码实现： class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { unordered_map&amp;lt;int,int&amp;gt; hm; for(int i=0;i&amp;lt;nums.</description>
    </item>
    
    <item>
      <title>【LeetCode】8. String to Integer (atoi)</title>
      <link>https://HauyuChen.github.io/post/008-string-to-integeratoi/</link>
      <pubDate>Thu, 11 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/008-string-to-integeratoi/</guid>
      <description>题目描述：  Implement atoi to convert a string to an integer.
Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.
Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.
Update (2015-02-10): The signature of the C++ function had been updated.</description>
    </item>
    
    <item>
      <title>Zhihu</title>
      <link>https://HauyuChen.github.io/zhihu/</link>
      <pubDate>Sun, 12 Jun 2016 19:38:48 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/zhihu/</guid>
      <description>Hello,everyone.
Zhihu</description>
    </item>
    
    <item>
      <title>关于本站</title>
      <link>https://HauyuChen.github.io/contact/</link>
      <pubDate>Sun, 12 Jun 2016 19:38:48 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/contact/</guid>
      <description>© 2017. All rights reserved.
Update by Hov
Build with HUGO , Theme blackburn</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://HauyuChen.github.io/about/</link>
      <pubDate>Wed, 01 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/about/</guid>
      <description>关于我 我是陈浩宇，
在读计算机专业学生，
现居于广东。
此博客主要记录一些个人学习笔记、技术文章。
希望对您也有所帮助：）

联系我 Q Q：ODkzNzY5Mzkz （Base64）
邮箱：Hauyu.Chen@Gmail.com</description>
    </item>
    
    <item>
      <title></title>
      <link>https://HauyuChen.github.io/post/1zigbee-parking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/1zigbee-parking/</guid>
      <description>0 前言 智能停车系统是本人在大二下学期做的一个小项目。项目难度不大，主要涉及传感器数据采集、ZigBee组网、GPRS传输数据、数据库服务器程序的编写、微信公众账号开发，我们还做了一个小模型用来展示。
ZB-P-01 在本文中将着重讲述ZigBee部分，如何通过ZigBee网络采集数据并将数据发送给远程数据库服务器。
本文侧重讲的是实现思路，具体的技术细节可参考源代码。

1 项目简介 智能停车系统通过无线传感器网络监测停车场内的车位状态和亮度信息等数据，并对数据进行处理和存储，实现停车引导、防盗提醒和灯光控制等功能。
系统通过ZigBee结合GPRS无线网络将数据发送并存储到数据库服务器，最终通过客户端、移动终端等方式实现交互。用户还可以关注本停车系统的微信公众账号实时地了解停车场内的信息。本系统旨在提升停车场管理效率，改善用户体验。

2 项目思路 ZigBee部分主要完成的是传感器数据的采集和数据的传输,大体的思路是这样的：通过ZigBee终端节点上外接的传感器实现数据监测，并通过ZigBee网络将数据发送至ZigBee协调器，ZigBee协调器通过RS232串口线连接GPRS模块，通过AT指令将数据发送至远程数据库服务器。
2.1 ZigBee协调器 ZigBee协调器主要完成以下功能：
 组建ZigBee网络，供ZigBee终端等节点连接； 接收ZigBee终端发送的数据，经过处理后通过RS232串口发送给与之相连接的GPRS模块。如将停车场内的车位数据和亮度数据发送给远程数据库服务器。 根据空闲车位的数量，控制车位指示屏 2.2 ZigBee终端 ZigBee终端节点主要负责以下功能：
 采集车位数据（红外传感器）、采集亮度数据（光照数字传感器）、控制车位状态灯（LED灯）；
 将采集到的数据通过ZigBee网络发送给ZigBee协调器。
 接收ZigBee协调器发送过来的数据，并进行相应的处理，如开关灯操作。
  2.3 GPRS模块 要把 ZigBee 网络采集到的数据发送给远程数据库服务器，可选用 GPRS 模块。通过SIM卡，利用 GPRS 网络将数据发送出去。GPRS模块主要完成以下功能：
 建立TCP连接，连接到远程服务器。 发送数据给远程服务器，接收远程服务器返回的数据； 发送防盗提醒短信给用户。  
3 实现细节 3.1 ZigBee终端 前面已经提到ZigBee终端节点负责的功能，下面说说ZigBee终端如何实现这些功能。
3.1.1 数据采集 ZigBee终端通过外接传感器采集数据，比如在本项目中用到的传感器主要是红外传感器、光照数字传感器。 （1）红外传感器 红外传感器采用黑白对管红外避障模块，有三个引脚，VCC。GND、OUT。探测距离可调，当前方有障碍物时OUT口输出1，否则输出0。使用较为方便，但是稳定性不足，也可考虑用超声波探测模块来替换。 如何探测车位状态。其实很简单，将传感器的OUT口连接到ZigBee终端的一个IO口，通过判断这个IO口的值来模拟车位是否被占用，控制车位状态灯（IO口）。当车位被占用，OUT口输出1；车位空闲，OUT口输出0。 实现代码参考附录的源代码（ParkingStatus.c）
（2）光照数字传感器 光照数字传感器用来采集停车场内的亮度数据，该传感器可以采集到周围环境的亮度值。该传感器采用IIC总线方式，有四个引脚（VCC、GND、SCL、SDA），将其与ZigBee终端连接即可，采集到的数据将通过ZigBee网络发送至ZigBee协调器。 实现代码参考附录的源代码（LightControl.c）
3.1.2 发送数据 在ZigBee网络中如何发送数据呢？看过协议栈例程的都应该清楚。ZigBee协议栈中发送数据的函数是 AF_DataRequest 。在此函数中我们主要考虑三个参数：簇ID（标识符）、数据大小、数据存放位置（数组名）。
下面是ZigBee终端发送车位数据给ZigBee协调器的代码：</description>
    </item>
    
  </channel>
</rss>