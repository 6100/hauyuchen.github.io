<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="设计模式学习笔记">
  <meta name="generator" content="Hugo 0.24.1" />

  <title>【设计模式】3.装饰者模式 &middot; Hov&#39;s Blog</title>

  <script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?dd096f3aba9332e2640cda59d3786695";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>	
  
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.2/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.2/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.2/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://HauyuChen.github.io/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://HauyuChen.github.io/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://HauyuChen.github.io/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://HauyuChen.github.io/img/favicon.ico" type="image/x-icon" />

  
  


</head>


<body>

<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  <a class="pure-menu-heading brand" href="https://HauyuChen.github.io/">
  <img src="https://HauyuChen.github.io/img/Hov.jpg" width="125px">
</a>

  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://HauyuChen.github.io/"><i class='fa fa-home fa-fw'></i>主页</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://HauyuChen.github.io/post/"><i class='fa fa-list fa-fw'></i>所有文章</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://HauyuChen.github.io/tags/"><i class='fa fa-folder fa-fw'></i>文章分类</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://HauyuChen.github.io/topics/"><i class='fa fa-tags fa-fw'></i>关键词</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://HauyuChen.github.io/about-me/"><i class='fa fa-user fa-fw'></i>关于我</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://HauyuChen.github.io/about-site/"><i class='fa fa-home fa-fw'></i>关于本站</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">

  <ul class="pure-menu-list">
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/HauyuChen" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    
	</ul>
	<ul class="pure-menu-list">
	
	<li class="pure-menu-item">
      <a class="pure-menu-link" href="http://blog.csdn.net/u014134180" target="_blank"><i class="fa fa-lastfm-square fa-fw"></i>友链：Wu_Being</a>
    </li>
  </ul>
  
</div>


  <div>


</div>

</div>


  <div id="main">


<div class="header">
  <h1>【设计模式】3.装饰者模式</h1>
  <h2>设计模式学习笔记</h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2017-08-29</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://HauyuChen.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a>
    
  </div>
  
  

  
  
  
  <div>
	<i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://HauyuChen.github.io/topics/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a>&nbsp;&#47;
    
      <a class="post-taxonomy-topic" href="https://HauyuChen.github.io/topics/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F">装饰者模式</a>&nbsp;&#47;
    
      <a class="post-taxonomy-topic" href="https://HauyuChen.github.io/topics/java">Java</a>
    
  </div>
  
  
  
</div>

  

<hr />

<p><em>版权声明：本文由 Hov 所有，发布于 <a href="http://chenhy.com">http://chenhy.com</a> ，转载请注明出处。<br/></em></p>

<hr />

<p><br/></p>

<h1 id="1-装饰者模式">1 装饰者模式</h1>

<h2 id="1-1-简介">1.1 简介</h2>

<p>装饰者模式可动态地向对象添加额外的属性或行为。装饰者模式是类继承的另外一种选择，类继承在编译时候增加行为，而装饰模式是在运行时增加行为。在对象功能扩展方面，装饰者模式比继承更有弹性。</p>

<h2 id="1-2-思路">1.2 思路</h2>

<p>通过增加一个装饰类包裹原来的类，包裹的方式一般是通过将原来的对象作为装饰类的构造函数的参数，从而在原有对象上添加新的功能。</p>

<h2 id="1-3-使用场景">1.3 使用场景</h2>

<p>在不影响其它对象的情况下，想要动态地给单个对象添加新的属性或功能。</p>

<h2 id="1-4-优缺点">1.4 优缺点</h2>

<p>优点：</p>

<ol>
<li>可用一个或多个装饰者包装一个对象，扩展性强；</li>
<li>对象可以在任何时候被修饰，即动态修饰对象；</li>
<li>非继承，避免子类爆炸。</li>
</ol>

<p>缺点：</p>

<ol>
<li>出现额外的装饰类，使程序变得复杂。</li>
</ol>

<p><br/></p>

<h1 id="2-实例">2 实例</h1>

<p>模拟咖啡店：</p>

<p>假设，咖啡店有两种咖啡可选： Decaf 和 Espresso ，两种配料可选： Chocalate 和 Milk 。</p>

<p>不同的咖啡和配料可以搭配成不同的饮品，比如 Decaf 、 Espresso 、 Decaf + Chocalate 、 Decaf + Milk 、 Espresso + Chocalate 、 Espresso + Milk 六种不同的饮品。</p>

<p>我们要写个程序来计算不同饮品的价格，比如客户点了一杯 Espresso + Chocalate ，输出饮品的价格和描述信息。</p>

<h2 id="2-1-糟糕的解决方案">2.1 糟糕的解决方案</h2>

<p>设计超类 Drink ，继承自超类 Drink 的子类 Decaf 、 Espresso 、 Decaf + Chocalate 、 Decaf + Milk 、 Espresso + Chocalate 、 Espresso + Milk 。</p>

<p>显然，每种组合的饮品都要写成一个子类。这样将导致子类爆炸，设想种类多的时候将有几百上千个不同的饮品子类。</p>

<p>这样的方案虽然设计简单，只需写个超类，然后将所有不同的饮品通通继承自超类即可。但是缺点是显而易见的，几百个饮品将对应几百个子类，不合理。</p>

<p><br/></p>

<p><img src="https://raw.githubusercontent.com/HauyuChen/PicsBox/master/ZSZMS-02.PNG" alt="" /></p>

<p><br/></p>

<h2 id="2-2-好一些的解决方案">2.2 好一些的解决方案</h2>

<ol>
<li>在超类 Drink 中定义 hasChocalate 、 setChocalate 、 hasMilk 、 setMilk 方法；</li>
<li>Decaf 、 Espresso 作为超类 Drink 的子类；</li>
<li>当需要 Decaf + Chocalate 就调用超类的 setChocalate 方法添加 Chocolate ，再通过 hasChocalate 方法计算总价。</li>
</ol>

<p>这种方法比上一种方法好一些，显然它不会引起类的爆炸。但是，因为配料相关的代码都是写在超类 Drink 里面的，如果我们要增加一种新的配料，就必须要修改超类 Drink ，这样维护性不好。</p>

<p><br/></p>

<p><img src="https://raw.githubusercontent.com/HauyuChen/PicsBox/master/ZSZMS-01.PNG" alt="" /></p>

<p><br/></p>

<h2 id="2-3-基于装饰者模式的解决方案">2.3 基于装饰者模式的解决方案</h2>

<p>基于装饰者模式，咖啡作为主体（被装饰者），配料作为装饰者。通过装饰类包裹主体，从而实现主体的动态扩展。</p>

<p><strong>（1）超类 Drink</strong></p>

<p>创建超类 Drink ，其包含饮品的基本属性，如描述、价格、子类应该实现的方法。</p>

<pre><code>/* Drink.java */

public abstract class Drink {
    
    public String description = &quot;&quot;;     //描述
    private float price = 0f;           //价格
    
    public abstract float cost();
    
    public String getDescription() {
        return description+&quot;-&quot;+this.getPrice();
    }
    public void setDescription(String description) {
        this.description = description;
    }
    public float getPrice() {
        return price;
    }
    public void setPrice(float price) {
        this.price = price;
    }
    
}
</code></pre>

<p><strong>（2）被装饰者（ConcreteComponent）</strong></p>

<p>前面我们提到咖啡店有 Decaf 、 Espresso 两种咖啡，其实咖啡就是主体（被装饰者），我们可以往咖啡加入不同的配料“装饰”成不同的饮品。</p>

<p>Decaf 、 Espresso 继承自 Coffee ， Coffee 继承自 Drink 。也就是说，主体下有两种类型的咖啡，以后我们新增一种类型的咖啡 LongBlack ，就只需让 LongBlack 像 Decaf 那样继承自 Coffee 即可，而无需修改超类 Drink 。</p>

<pre><code>/* Coffee.java */

public class Coffee extends Drink {     //主体中间层

    @Override
    public float cost() {               //返回价格
        return super.getPrice();    
    }

}
</code></pre>

<pre><code>/* Decaf.java */

public class Decaf extends Coffee {     // Decaf 咖啡（被装饰者）
    
    public Decaf() {
        super.setDescription(&quot;Decaf&quot;);  //描述
        super.setPrice(3.0f);           //价格
    }
    
}
</code></pre>

<pre><code>/* Espresso.java */

public class Espresso extends Coffee {      // Espresso 咖啡（被装饰者）
    
    public Espresso() {
        super.setDescription(&quot;Espresso&quot;);   //描述
        super.setPrice(4.0f);               //价格
    }
    
}
</code></pre>

<p><strong>（3）装饰者（Decorator）</strong></p>

<p>咖啡可以加不同的配料，如牛奶、巧克力等等。牛奶、巧克力就是装饰者，通过它们包装被装饰者，从而使被装饰者实现动态扩展。</p>

<pre><code>/* Decorator.java */

public class Decorator extends Drink {      //中间层

    private Drink Obj;                      //被装饰的对象
    
    public Decorator(Drink Obj) {
        this.Obj = Obj;
    };
    
    @Override
    public float cost() {
        return super.getPrice()+Obj.cost();     //计算价格，要加上被装饰对象原有的价格
    }
    
    public String getDescription() {
        return super.description + &quot;-&quot; + super.getPrice() + &quot; &amp;&amp; &quot; +Obj.getDescription();   //递归增加原有属性
    }

}
</code></pre>

<pre><code>/* Chocolate.java */

public class Chocolate extends Decorator {  //巧克力（装饰者）
    
    public Chocolate(Drink Obj) {           
        super(Obj);
        super.setDescription(&quot;Chocolate&quot;);  //描述
        super.setPrice(3.0f);               //价格
    }
    
}
</code></pre>

<pre><code>/* Milk.java */

public class Milk extends Decorator {   //牛奶（装饰者）
    
    public Milk(Drink Obj) {
        super(Obj);
        super.setDescription(&quot;Milk&quot;);   //描述
        super.setPrice(2.0f);           //价格
    }
    
}
</code></pre>

<p>至此，我们已经完成了基础代码的编写。</p>

<p>我们设计了一个超类 Drink ，两个中间层 Coffee 、 Decorator ，两个继承自中间层 Coffee 的具体实现类 Decaf 、 Espresso ，两个继承自中间层 Decorator 的具体实现类 Chocolate 、 Milk 。</p>

<p>代码结构如下：</p>

<p><br/></p>

<p><img src="https://raw.githubusercontent.com/HauyuChen/PicsBox/master/ZSZMS-03.jpg" alt="" /></p>

<p><br/></p>

<p><strong>（4）测试</strong></p>

<p>咖啡店新增了两个订单。</p>

<p>订单 1 ：客户单点了一杯 Decaf ；</p>

<p>订单 2 ：客户点了一杯 Espresso + Milk + Chocolate + Chocolate 。</p>

<p>最终，分别输出两个订单的饮品价格、饮品描述。</p>

<p>订单 2 结构如下：</p>

<p><img src="https://raw.githubusercontent.com/HauyuChen/PicsBox/master/Espresso.png" alt="" /></p>

<pre><code>/* CoffeeBar.java */

public class CoffeeBar {

    public static void main(String[] args) {

        Drink order;    //订单

        //订单 1 ：只点Decaf，不加任何配料
        order = new Decaf();    //点一杯Decaf
        System.out.println(&quot;Order 1 Price:\n&quot;+order.cost());            //输出饮品价格
        System.out.println(&quot;Order 1 Desc:\n&quot;+order.getDescription());   //输出饮品描述
        
        System.out.println(&quot;******************&quot;);
        
        //订单 2 ：点一杯 Espress o，加一份 Milk 、两份 Chocolate
        order = new Espresso(); //点一杯Espresso
        order = new Milk(order);        // Milk 装饰 Espresso（加一份 Milk ）
        order = new Chocolate(order);   // Chocolate 装饰 Espresso + Milk（再加一份 Chocolate ）
        order = new Chocolate(order);   // Chocolate 装饰 Espresso + Milk + Chocolate（再加一份 Chocolate ）
        System.out.println(&quot;Order 2 Price:\n&quot;+order.cost());            //输出饮品价格
        System.out.println(&quot;Order 2 Desc:\n&quot;+order.getDescription());   //输出饮品描述
        
    }

}
</code></pre>

<p><strong>CoffeeBar.java 运行结果：</strong></p>

<pre><code>Order 1 Price:
3.0
Order 1 Desc:
Decaf-3.0
******************
Order 2 Price:
12.0
Order 2 Desc:
Chocolate-3.0 &amp;&amp; Chocolate-3.0 &amp;&amp; Milk-2.0 &amp;&amp; Espresso-4.0
</code></pre>

<p><br/></p>

<h1 id="3-结语">3 结语</h1>

<p>前面我们通过了一个实例来讲解装饰者模式。不同于直接使用继承，装饰者通过装饰类包裹被装饰对象实现扩展。</p>

<p>具体到例子中，两种咖啡（Decaf、Espresso），两种配料（Chocolate、Milk）。现在我们要实现 Decaf + Milk 的组合，常规的做法是 Decaf + Milk 直接继承自 Drink 这个超类，从而具备饮品的相关属性，但这样会引起子类爆炸。</p>

<p>通过装饰者模式，我们不直接使用继承。通过 Coffee 、 Decorator 作为中间层， Coffee 继承自超类 Drink ，显然 Coffee 具有基本的饮品属性（如 Decaf 、Espresso）。我们想要在 Decaf 上加入 Milk ，只需用 Decorator 中的 Milk 去包裹 Decaf 对象，从而 Decaf 对象增加了 Milk 相关的属性。</p>

<p>这就是装饰者模式实现动态扩展的思路。</p>

<p><br/></p>


  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
    <a href="https://HauyuChen.github.io/post/566-reshape-the-matrix/"><i class="fa fa-chevron-left"></i></a>
    
  </div>
  <div class="pure-u-10-24">
    
    <nav class="prev">
      <a href="https://HauyuChen.github.io/post/566-reshape-the-matrix/">【LeetCode】566. Reshape the Matrix</a>
    </nav>
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
    <nav class="next">
      <a href="https://HauyuChen.github.io/post/%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/">重写、重载的区别</a>
    </nav>
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
    <a href="https://HauyuChen.github.io/post/%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/"><i class="fa fa-chevron-right"></i></a>
    
  </div>
</div>



  
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = "http-hov-space";
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

</div>
</div>
<script src="https://HauyuChen.github.io/js/ui.js"></script>






</body>
</html>

