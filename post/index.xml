<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hov&#39;s Blog</title>
    <link>https://hauyuchen.github.io/post/</link>
    <description>Recent content in Posts on Hov&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Wed, 29 Mar 2017 17:54:21 +0100</lastBuildDate>
    
	<atom:link href="https://hauyuchen.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>136. Single Number</title>
      <link>https://hauyuchen.github.io/post/136-single-number/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/136-single-number/</guid>
      <description> 题目描述：  Given an array of integers, every element appears twice except for one. Find that single one.
Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
 代码实现： class Solution { public: int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ret = 0; for(int num:nums){ ret^=num; } return ret; } };  </description>
    </item>
    
    <item>
      <title>167. Two Sum II - Input array is sorted</title>
      <link>https://hauyuchen.github.io/post/167-two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/167-two-sum-ii-input-array-is-sorted/</guid>
      <description>题目描述：  Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution and you may not use the same element twice.</description>
    </item>
    
    <item>
      <title>169. Majority Element</title>
      <link>https://hauyuchen.github.io/post/169-majority-element/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/169-majority-element/</guid>
      <description> 题目描述：  Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
 代码实现： class Solution { public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int major=nums[0]; int cnt=1; for(int num:nums){ if(num==major){ ++cnt; }else{ --cnt; } if(cnt==0){ ++cnt; major = num; } } return major; } };  </description>
    </item>
    
    <item>
      <title>171. Excel Sheet Column Number</title>
      <link>https://hauyuchen.github.io/post/171-excel-sheet-column-number/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/171-excel-sheet-column-number/</guid>
      <description> 题目描述：  Related to question Excel Sheet Column Title
Given a column title as appear in an Excel sheet, return its corresponding column number.
For example:
A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28   代码实现： class Solution { public: int titleToNumber(string s) { int sum=0; for(int i=0;i&amp;lt;s.length();i++){ sum = sum*26+(s[i]-&#39;A&#39;+1); } return sum; } };  </description>
    </item>
    
    <item>
      <title>191. Number of 1 Bits</title>
      <link>https://hauyuchen.github.io/post/191-number-of-1-bits/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/191-number-of-1-bits/</guid>
      <description> 题目描述：  Write a function that takes an unsigned integer and returns the number of ’1&amp;rsquo; bits it has (also known as the Hamming weight).
For example, the 32-bit integer ’11&amp;rsquo; has binary representation 00000000000000000000000000001011, so the function should return 3.
 代码实现： class Solution { public: int hammingWeight(uint32_t n) { int sum=0; while(n&amp;gt;0){ if(n&amp;amp;1==1){ sum++; } n=n&amp;gt;&amp;gt;1; } return sum; } };  </description>
    </item>
    
    <item>
      <title>206. Reverse Linked List</title>
      <link>https://hauyuchen.github.io/post/206-reverse-linked-list/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/206-reverse-linked-list/</guid>
      <description> 题目描述：  Reverse a singly linked list.
 代码实现： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* pPre=nullptr; ListNode* pNode=head; ListNode* pRet=nullptr; while(pNode!=nullptr){ ListNode* pNext=pNode-&amp;gt;next; if(pNext==nullptr){ pRet=pNode; } pNode-&amp;gt;next=pPre; pPre=pNode; pNode=pNext; } return pRet; } };  </description>
    </item>
    
    <item>
      <title>217. Contains Duplicate</title>
      <link>https://hauyuchen.github.io/post/217-contains-duplicate/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/217-contains-duplicate/</guid>
      <description> 题目描述：  Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
 代码实现： class Solution { public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_set&amp;lt;int&amp;gt; set; for(int num:nums){ if(set.count(num)){ return true; } set.insert(num); } return false; } };  </description>
    </item>
    
    <item>
      <title>226. Invert Binary Tree</title>
      <link>https://hauyuchen.github.io/post/226-invert-binary-tree/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/226-invert-binary-tree/</guid>
      <description>题目描述：  Invert a binary tree.
 4 / \ 2 7 / \ / \ 1 3 6 9 to 4 / \ 7 2 / \ / \ 9 6 3 1  Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</description>
    </item>
    
    <item>
      <title>231. Power of Two</title>
      <link>https://hauyuchen.github.io/post/231-power-of-two/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/231-power-of-two/</guid>
      <description> 题目描述：  Given an integer, write a function to determine if it is a power of two.
 代码实现： class Solution { public: bool isPowerOfTwo(int n) { int flag=0; if(n&amp;lt;=0){ return false; } while(n&amp;gt;0){ if(n&amp;amp;1==1){ if(flag==1){ return false; } flag=1; } n=n&amp;gt;&amp;gt;1; } return true; } };  </description>
    </item>
    
    <item>
      <title>237. Delete Node in a Linked List</title>
      <link>https://hauyuchen.github.io/post/237-delete-node-in-a-linked-list/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/237-delete-node-in-a-linked-list/</guid>
      <description> 题目描述：  Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.
Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.
 代码实现： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { auto next = node-&amp;gt;next; *node = *next; delete next; } };  </description>
    </item>
    
    <item>
      <title>258. Add Digits</title>
      <link>https://hauyuchen.github.io/post/258-add-digits/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/258-add-digits/</guid>
      <description> 题目描述：  Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
For example:
Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.
Follow up: Could you do it without any loop/recursion in O(1) runtime?
 代码实现： class Solution { public: int addDigits(int num) { return 1+(num-1)%9; } };  </description>
    </item>
    
    <item>
      <title>263. Ugly Number</title>
      <link>https://hauyuchen.github.io/post/263-ugly-number/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/263-ugly-number/</guid>
      <description>题目描述：  Write a program to check whether a given number is an ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.
Note that 1 is typically treated as an ugly number.
 代码实现： class Solution { public: bool isUgly(int num) { if(num&amp;lt;=0){ return false; } while(num%2==0){ num/=2; } while(num%3==0){ num/=3; } while(num%5==0){ num/=5; } return num==1?</description>
    </item>
    
    <item>
      <title>268. Missing Number</title>
      <link>https://hauyuchen.github.io/post/268-missing-number/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/268-missing-number/</guid>
      <description>题目描述：  Given an array containing n distinct numbers taken from 0, 1, 2, &amp;hellip;, n, find the one that is missing from the array.
For example, Given nums = [0, 1, 3] return 2.
Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
 代码实现： class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int sum=0; int realsum=0; bool flag=false; for(int i=0;i&amp;lt;nums.</description>
    </item>
    
    <item>
      <title>283. Move Zeroes</title>
      <link>https://hauyuchen.github.io/post/283-move-zeroes/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/283-move-zeroes/</guid>
      <description>题目描述：  Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
Note: You must do this in-place without making a copy of the array. Minimize the total number of operations.
 代码实现： class Solution { public: void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int index=0; for(int i=0;i&amp;lt;nums.</description>
    </item>
    
    <item>
      <title>242. Valid Anagram</title>
      <link>https://hauyuchen.github.io/post/242-valid-anagram/</link>
      <pubDate>Tue, 21 Mar 2017 20:54:45 +0000</pubDate>
      
      <guid>https://hauyuchen.github.io/post/242-valid-anagram/</guid>
      <description>题目描述：  Given two strings s and t, write a function to determine if t is an anagram of s.
For example, s = &amp;ldquo;anagram&amp;rdquo;, t = &amp;ldquo;nagaram&amp;rdquo;, return true. s = &amp;ldquo;rat&amp;rdquo;, t = &amp;ldquo;car&amp;rdquo;, return false.
Note: You may assume the string contains only lowercase alphabets.
Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?
 代码实现： class Solution { public: bool isAnagram(string s, string t) { if(s.</description>
    </item>
    
    <item>
      <title>1. Two Sum</title>
      <link>https://hauyuchen.github.io/post/001-two-sum/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/001-two-sum/</guid>
      <description>题目描述：  Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example: Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].
 代码实现： class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { unordered_map&amp;lt;int,int&amp;gt; hm; for(int i=0;i&amp;lt;nums.</description>
    </item>
    
    <item>
      <title>100. Same Tree</title>
      <link>https://hauyuchen.github.io/post/100-same-tree/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/100-same-tree/</guid>
      <description>题目描述：  Given two binary trees, write a function to check if they are equal or not.
Two binary trees are considered equal if they are structurally identical and the nodes have the same value.
 代码实现： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p==nullptr &amp;amp;&amp;amp; q==nullptr){ return true; } else if(p==nullptr || q==nullptr){ return false; } if(p-&amp;gt;val!</description>
    </item>
    
    <item>
      <title>104. Maximum Depth of Binary Tree</title>
      <link>https://hauyuchen.github.io/post/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/104-maximum-depth-of-binary-tree/</guid>
      <description>题目描述：  Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
 代码实现： /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int maxDepth(TreeNode *root) { int Ldepth=0,Rdepth=0; if(root==NULL){ return 0; } if(root-&amp;gt;left==NULL &amp;amp;&amp;amp; root-&amp;gt;right==NULL){ return 1; } Ldepth=maxDepth(root-&amp;gt;left); Rdepth=maxDepth(root-&amp;gt;right); return 1+(Ldepth&amp;gt;Rdepth?</description>
    </item>
    
    <item>
      <title>121. Best Time to Buy and Sell Stock</title>
      <link>https://hauyuchen.github.io/post/121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/121-best-time-to-buy-and-sell-stock/</guid>
      <description>题目描述：  Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5
max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: Input: [7, 6, 4, 3, 1] Output: 0</description>
    </item>
    
    <item>
      <title>122. Best Time to Buy and Sell Stock II</title>
      <link>https://hauyuchen.github.io/post/122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>题目描述：  Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>13. Roman to Integer</title>
      <link>https://hauyuchen.github.io/post/013-roman-to-integer/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/013-roman-to-integer/</guid>
      <description> 题目描述：  Given a roman numeral, convert it to an integer.
Input is guaranteed to be within the range from 1 to 3999.
 代码实现： class Solution { public: int romanToInt(string s) { unordered_map&amp;lt;char,int&amp;gt; hm; hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;I&#39;,1)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;V&#39;,5)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;X&#39;,10)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;L&#39;,50)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;C&#39;,100)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;D&#39;,500)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;M&#39;,1000)); int sum=hm[s[s.size()-1]]; for(int i=s.size()-1;i&amp;gt;0;--i){ if(hm[s[i]]&amp;gt;hm[s[i-1]]){ sum-=hm[s[i-1]]; }else{ sum+=hm[s[i-1]]; } } return sum; } };  </description>
    </item>
    
    <item>
      <title>21. Merge Two Sorted Lists</title>
      <link>https://hauyuchen.github.io/post/021-merge-two-sorted-lists/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/021-merge-two-sorted-lists/</guid>
      <description>题目描述：  Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
 代码实现： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1==nullptr&amp;amp;&amp;amp;l2==nullptr) return nullptr; if(l1==nullptr || l2==nullptr) return (l1==nullptr)?</description>
    </item>
    
    <item>
      <title>53. Maximum Subarray</title>
      <link>https://hauyuchen.github.io/post/053-maximum-subarray/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/053-maximum-subarray/</guid>
      <description> 题目描述：  Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6.
 代码实现： int maxSubArray(int* nums, int numsSize) { int sum=0; int max=INT_MIN; for(int i=0;i&amp;lt;numsSize;i++){ sum+=nums[i]; if(sum&amp;gt;max){ max = sum; } if(sum&amp;lt;0){ sum = 0; } } return max; }  </description>
    </item>
    
    <item>
      <title>69. Sqrt(x)</title>
      <link>https://hauyuchen.github.io/post/069-sqrtx/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/069-sqrtx/</guid>
      <description> 题目描述：  Implement int sqrt(int x).
Compute and return the square root of x.
 代码实现： class Solution { public: int mySqrt(int x) { if(x==0){ return 0; } int low=1,high=x; int mid; while(1){ mid = (low+high)/2; if(mid&amp;gt;x/mid){ high = mid-1; } else{ if((mid+1)&amp;gt;(x/(mid+1))){ return mid; } low = mid+1; } } } };  </description>
    </item>
    
    <item>
      <title>70. Climbing Stairs</title>
      <link>https://hauyuchen.github.io/post/070-climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/070-climbing-stairs/</guid>
      <description> 题目描述：  You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
 思路：  这题本质上是斐波那契数列问题。这里采用数组暂存已有结果，以时间换空间，减少递归带来的重复计算。
 代码实现： class Solution { public: int climbStairs(int n) { int f[n+1]; f[0]=1; f[1]=1; for(int i=2;i&amp;lt;=n;++i){ f[i]=f[i-1]+f[i-2]; } return f[n]; } };  </description>
    </item>
    
    <item>
      <title>8. String to Integer (atoi)</title>
      <link>https://hauyuchen.github.io/post/008-string-to-integeratoi/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/008-string-to-integeratoi/</guid>
      <description>题目描述：  Implement atoi to convert a string to an integer.
Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.
Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.
Update (2015-02-10): The signature of the C++ function had been updated.</description>
    </item>
    
    <item>
      <title>202. Happy Number</title>
      <link>https://hauyuchen.github.io/post/202-happy-number/</link>
      <pubDate>Mon, 29 Aug 2016 17:54:21 +0100</pubDate>
      
      <guid>https://hauyuchen.github.io/post/202-happy-number/</guid>
      <description>题目描述：  Write an algorithm to determine if a number is &amp;ldquo;happy&amp;rdquo;.
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
  </channel>
</rss>