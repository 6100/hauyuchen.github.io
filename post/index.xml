<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hov&#39;s Blog</title>
    <link>https://HauyuChen.github.io/post/</link>
    <description>Recent content in Posts on Hov&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Thu, 29 Jun 2017 17:54:21 +0100</lastBuildDate>
    
	<atom:link href="https://HauyuChen.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>String相关特性</title>
      <link>https://HauyuChen.github.io/post/java-string/</link>
      <pubDate>Thu, 29 Jun 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java-string/</guid>
      <description>声明：本文是我对Java中String的特性的一些笔记，描述较为简练，有误之处还望指正。
 1.字符串实例化两种方式的区别 String的实例化方式有两种，一种是直接赋值，另一种是通过new关键字实例化。
（1）直接赋值
String str1 = &amp;quot;hello&amp;quot;;  （2）new关键字
String str2 = new String(&amp;quot;hello&amp;quot;);  两种方式都能实例化新的字符串，那我们用哪种方式比较好呢？ 这要先弄清楚他们之间的区别。
 str1是通过直接赋值，str1将直接指向一个存放“hello”的内存空间，因此至占用一个内存空间。 str2是通过new关键字实例化，通过new关键字将开辟一个新的内存空间，赋值后将开辟一个新的内存空间存放str2，也就是说使用new关键字实例化字符串总共开辟了两个内存空间。  综上，使用直接赋值的方法较好，毕竟可以避免占用多余的内存空间。

2.字符串比较“==”与equals的区别 字符串比较是较为常用的功能，Java中主要提供了两种字符串比较方式，“==”和equals，如下：
String str1 = &amp;quot;hello&amp;quot;; String str2 = new String(&amp;quot;hello&amp;quot;); System.out.println(str1==str2); //false System.out.println(str1.equals(str2)); //true  奇怪，明明str1和str2是一样的，为什么“==”会是false呢？
这是因为，“==”比较的是内存单元地址，equals比较的是内容。由前一小节可知，new关键字实例化方式会开辟两个内存空间，str1和str2虽然都是hello，但他们存放的内存空间是不一样的。

3.String内容不可变 假设：
String str = &amp;quot;hello&amp;quot;; str = str + &amp;quot;world!&amp;quot;;  分析：原先str指向的是存放“hello”的内存空间，经过重新赋值，并不会将内存空间的“hello”改成“helloworld!”,而是开辟了新的内存空间存放“helloworld!”，将str重新指向存放“helloworld!”的内存空间。</description>
    </item>
    
    <item>
      <title>447. Number of Boomerangs</title>
      <link>https://HauyuChen.github.io/post/447-number-of-boomerangs/</link>
      <pubDate>Mon, 29 May 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/447-number-of-boomerangs/</guid>
      <description>题目描述：  Given n points in the plane that are all pairwise distinct, a &amp;ldquo;boomerang&amp;rdquo; is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).
Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range -10000, 10000.</description>
    </item>
    
    <item>
      <title>448. Find All Numbers Disappeared in an Array</title>
      <link>https://HauyuChen.github.io/post/448-find-all-numbers-disappeared-in-an-array/</link>
      <pubDate>Mon, 29 May 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/448-find-all-numbers-disappeared-in-an-array/</guid>
      <description>题目描述：  Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements of [1, n] inclusive that do not appear in this array.
Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.
Example:
Input: [4,3,2,7,8,2,3,1]
Output: [5,6]</description>
    </item>
    
    <item>
      <title>453. Minimum Moves to Equal Array Elements</title>
      <link>https://HauyuChen.github.io/post/453-minimum-moves-to-equal-array-elements/</link>
      <pubDate>Mon, 29 May 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/453-minimum-moves-to-equal-array-elements/</guid>
      <description>题目描述：  Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.
Example:
Input: [1,2,3]
Output: 3
Explanation: Only three moves are needed (remember each move increments two elements): [1,2,3] =&amp;gt; [2,3,3] =&amp;gt; [3,4,3] =&amp;gt; [4,4,4]
 代码实现： class Solution { public: int minMoves(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int min=INT_MAX; int sum=0; for(int num:nums){ min=min&amp;lt;num?</description>
    </item>
    
    <item>
      <title>455. Assign Cookies</title>
      <link>https://HauyuChen.github.io/post/455-assign-cookies/</link>
      <pubDate>Mon, 29 May 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/455-assign-cookies/</guid>
      <description>题目描述：  Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &amp;gt;= gi, we can assign the cookie j to the child i, and the child i will be content.</description>
    </item>
    
    <item>
      <title>461. Hamming Distance</title>
      <link>https://HauyuChen.github.io/post/461-hamming-distance/</link>
      <pubDate>Mon, 29 May 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/461-hamming-distance/</guid>
      <description>题目描述：  The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Given two integers x and y, calculate the Hamming distance.
Note: 0 ≤ x, y &amp;lt; 231.
Example:
Input: x = 1, y = 4
Output: 2
Explanation:
1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑  The above arrows point to positions where the corresponding bits are different.</description>
    </item>
    
    <item>
      <title>463. Island Perimeter</title>
      <link>https://HauyuChen.github.io/post/463-island-perimeter/</link>
      <pubDate>Mon, 29 May 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/463-island-perimeter/</guid>
      <description>题目描述：  You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn&amp;rsquo;t have &amp;ldquo;lakes&amp;rdquo; (water inside that isn&amp;rsquo;t connected to the water around the island). One cell is a square with side length 1.</description>
    </item>
    
    <item>
      <title>476. Number Complement</title>
      <link>https://HauyuChen.github.io/post/476-number-complement/</link>
      <pubDate>Mon, 29 May 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/476-number-complement/</guid>
      <description>题目描述：  Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.
Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation.
Example 1: Input: 5 Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010.</description>
    </item>
    
    <item>
      <title>485. Max Consecutive Ones</title>
      <link>https://HauyuChen.github.io/post/485-max-consecutive-ones/</link>
      <pubDate>Mon, 29 May 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/485-max-consecutive-ones/</guid>
      <description>题目描述：  Given a binary array, find the maximum number of consecutive 1s in this array.
Example 1: Input: [1,1,0,1,1,1] Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.
Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000
 代码实现： class Solution { public: int findMaxConsecutiveOnes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int cnt=0,max=0; for(int num:nums){ if(num==1){ cnt++; }else{ cnt=0; } max = max&amp;gt;cnt?</description>
    </item>
    
    <item>
      <title>无线风扇</title>
      <link>https://HauyuChen.github.io/post/%E6%97%A0%E7%BA%BF%E9%A3%8E%E6%89%87/</link>
      <pubDate>Mon, 29 May 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/%E6%97%A0%E7%BA%BF%E9%A3%8E%E6%89%87/</guid>
      <description>翻了下硬盘，无意中发现了在大二时写的这篇文章。无线风扇是本人在大二上学期在实验室期间实现的项目，实现了电风扇的无线控制。这也是我学习无线传感器网络实现的第一个项目，看着实验室的电风扇真的被代码操控着，感觉真的很奇妙。
本文记录了项目的大体思路，希望对你有所帮助。
转载请注明出处：Hov-http://hov.space
 0 简介 无线风扇是本人接触 ZigBee 协议栈后完成的一个项目。实现风扇的手动和自动两种模式的控制。
 手动模式，ZigBee 协调器接收指令后控制风扇的开关； 自动模式，风扇根据周围环境的温度自动控制风扇，比如当周围温度大于等于 26 摄氏度时自动打开风扇。  大体的思路是这样的： 通过两个 ZigBee 模块组成一个 ZigBee 网络；ZigBee终端外接温湿度传感器，外接继电器，继电器与风扇连接；ZigBee 协调器通过串口 RS232 与电脑连接（也可以通过 ZigBee 协调器与 GPRS 模块连接，实现手机控制的功能）。
虽说是无线风扇功能，实质就是实现传感器数据采集和 IO 口控制。风扇控 制主要通过 IO 口导通继电器来实现，所以，如果继电器连接电灯，空调等等，那就可以实现不同功能了。
1 功能阐述 1.1 串口通讯 （1）ZigBee 网络采集的温湿度数据、风扇状态通过 RS232 串口传送给电脑，在串口调试助手上显示相关数据。
（2）电脑向 ZigBee 协调器发送指令，控制风扇的开关。
1.2 温湿度数据采集 （1）ZigBee 终端外接 DHT11 温湿度传感器，通过传感器采集周围环境的温湿度信息；
（2）ZigBee 终端采集到的温湿度数据通过 ZigBee 网络发送给 ZigBee 协调器；
1.3 风扇控制 风扇控制分为两种模式：手动模式和自动模式
手动模式：ZigBee 协调器接收到电脑发送的指令后根据指令控制电风扇。 如，当收到“FAN_Y”，电风扇打开；当受到“FAN_N”，电风扇关闭。
自动模式：风扇状态根据周围环境的温度自动调节。当周围环境温度大 于等于 26 摄氏度时，电风扇自动打开；当周围环境小于 26 摄氏度时，电风扇自动关闭。</description>
    </item>
    
    <item>
      <title>292. Nim Game</title>
      <link>https://HauyuChen.github.io/post/292-nim-game/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/292-nim-game/</guid>
      <description>题目描述：  You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.
Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</description>
    </item>
    
    <item>
      <title>326. Power of Three</title>
      <link>https://HauyuChen.github.io/post/326-power-of-three/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/326-power-of-three/</guid>
      <description> 题目描述：  Given an integer, write a function to determine if it is a power of three.
Follow up: Could you do it without using any loop / recursion?
 代码实现： class Solution { public: bool isPowerOfThree(int n) { if(n&amp;lt;=0){ return false; } while(n%3==0){ n/=3; } if(n==1){ return true; } return false; } };  </description>
    </item>
    
    <item>
      <title>338. Counting Bits</title>
      <link>https://HauyuChen.github.io/post/338-counting-bits/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/338-counting-bits/</guid>
      <description>题目描述：  Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;rsquo;s in their binary representation and return them as an array.
Example: For num = 5 you should return [0,1,1,2,1,2].
Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?</description>
    </item>
    
    <item>
      <title>344. Reverse String</title>
      <link>https://HauyuChen.github.io/post/344-reverse-string/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/344-reverse-string/</guid>
      <description> 题目描述：  Write a function that takes a string as input and returns the string reversed.
Example: Given s = &amp;ldquo;hello&amp;rdquo;, return &amp;ldquo;olleh&amp;rdquo;.
 代码实现： class Solution { public: string reverseString(string s) { reverse(s.begin(),s.end()); return s; } };  </description>
    </item>
    
    <item>
      <title>349. Intersection of Two Arrays</title>
      <link>https://HauyuChen.github.io/post/349-intersection-of-two-arrays/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/349-intersection-of-two-arrays/</guid>
      <description> 题目描述：  Given two arrays, write a function to compute their intersection.
Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].
Note: Each element in the result must be unique. The result can be in any order.
 代码实现： class Solution { public: vector&amp;lt;int&amp;gt; intersection(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { unordered_set&amp;lt;int&amp;gt; s; vector&amp;lt;int&amp;gt; ret; for(int num1:nums1){ if(s.count(num1)==0){ s.insert(num1); } } for(int num2:nums2){ if(s.count(num2)){ ret.push_back(num2); s.erase(num2); } } return ret; } };  </description>
    </item>
    
    <item>
      <title>350. Intersection of Two Arrays II</title>
      <link>https://HauyuChen.github.io/post/350-intersection-of-two-arrays-ii/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/350-intersection-of-two-arrays-ii/</guid>
      <description>题目描述：  Given two arrays, write a function to compute their intersection.
Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].
Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1&amp;rsquo;s size is small compared to nums2&amp;rsquo;s size?</description>
    </item>
    
    <item>
      <title>371. Sum of Two Integers</title>
      <link>https://HauyuChen.github.io/post/371-sum-of-two-integers/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/371-sum-of-two-integers/</guid>
      <description> 题目描述：  Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
Example: Given a = 1 and b = 2, return 3.
 代码实现： class Solution { public: int getSum(int a, int b) { return b==0?a:getSum(a^b,(a&amp;amp;b)&amp;lt;&amp;lt;1); } };  </description>
    </item>
    
    <item>
      <title>383. Ransom Note</title>
      <link>https://HauyuChen.github.io/post/383-ransom-note/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/383-ransom-note/</guid>
      <description>题目描述：  Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.
Each letter in the magazine string can only be used once in your ransom note.
Note: You may assume that both strings contain only lowercase letters.
 canConstruct(&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;) -&amp;gt; false canConstruct(&amp;ldquo;aa&amp;rdquo;, &amp;ldquo;ab&amp;rdquo;) -&amp;gt; false canConstruct(&amp;ldquo;aa&amp;rdquo;, &amp;ldquo;aab&amp;rdquo;) -&amp;gt; true   代码实现： class Solution { public: bool canConstruct(string ransomNote, string magazine) { if(magazine.</description>
    </item>
    
    <item>
      <title>387. First Unique Character in a String</title>
      <link>https://HauyuChen.github.io/post/387-first-unique-character-in-a-string/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/387-first-unique-character-in-a-string/</guid>
      <description> 题目描述：  Given a string, find the first non-repeating character in it and return it&amp;rsquo;s index. If it doesn&amp;rsquo;t exist, return -1.
Examples:
s = &amp;ldquo;leetcode&amp;rdquo; return 0.
s = &amp;ldquo;loveleetcode&amp;rdquo;, return 2.
Note: You may assume the string contain only lowercase letters.
 代码实现： class Solution { public: int firstUniqChar(string s) { int arr[26]; for(int i=0;i&amp;lt;26;++i){ arr[i]=0; } for(int i=0;i&amp;lt;s.size();++i){ ++arr[s[i]-&#39;a&#39;]; } for(int i=0;i&amp;lt;s.size();++i){ if(arr[s[i]-&#39;a&#39;]==1){ return i; } } return -1; } };  </description>
    </item>
    
    <item>
      <title>389. Find the Difference</title>
      <link>https://HauyuChen.github.io/post/389-find-the-difference/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/389-find-the-difference/</guid>
      <description>题目描述：  Given two strings s and t which consist of only lowercase letters.
String t is generated by random shuffling string s and then add one more letter at a random position.
Find the letter that was added in t.
Example:
Input: s = &amp;ldquo;abcd&amp;rdquo; t = &amp;ldquo;abcde&amp;rdquo;
Output: e
Explanation: &amp;lsquo;e&amp;rsquo; is the letter that was added.
 代码实现： class Solution { public: char findTheDifference(string s, string t) { char ch = t[0]; for(int i=1;i&amp;lt;t.</description>
    </item>
    
    <item>
      <title>401. Binary Watch</title>
      <link>https://HauyuChen.github.io/post/401-binary-watch/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/401-binary-watch/</guid>
      <description>题目描述：  A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).
Each LED represents a zero or one, with the least significant bit on the right.
For example, the above binary watch reads &amp;ldquo;3:25&amp;rdquo;.
Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</description>
    </item>
    
    <item>
      <title>404. Sum of Left Leaves</title>
      <link>https://HauyuChen.github.io/post/404-sum-of-left-leaves/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/404-sum-of-left-leaves/</guid>
      <description> 题目描述：  Find the sum of all left leaves in a given binary tree.
Example:
 3 / \ 9 20 / \ 15 7  There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
 代码实现： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int sumOfLeftLeaves(TreeNode* root) { if(root==nullptr){ return 0; } int sum=0; if(root-&amp;gt;left){ if(root-&amp;gt;left-&amp;gt;left==nullptr &amp;amp;&amp;amp; root-&amp;gt;left-&amp;gt;right==nullptr){ sum+=root-&amp;gt;left-&amp;gt;val; }else{ sum+=sumOfLeftLeaves(root-&amp;gt;left); } } if(root-&amp;gt;right){ sum+=sumOfLeftLeaves(root-&amp;gt;right); } return sum; } };  </description>
    </item>
    
    <item>
      <title>409. Longest Palindrome</title>
      <link>https://HauyuChen.github.io/post/409-longest-palindrome/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/409-longest-palindrome/</guid>
      <description>题目描述：  Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.
This is case sensitive, for example &amp;ldquo;Aa&amp;rdquo; is not considered a palindrome here.
Note: Assume the length of given string will not exceed 1,010.
Example:
Input: &amp;ldquo;abccccdd&amp;rdquo;
Output: 7
Explanation: One longest palindrome that can be built is &amp;ldquo;dccaccd&amp;rdquo;, whose length is 7.</description>
    </item>
    
    <item>
      <title>412. Fizz Buzz</title>
      <link>https://HauyuChen.github.io/post/412-fizz-buzz/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/412-fizz-buzz/</guid>
      <description>题目描述：  Write a program that outputs the string representation of numbers from 1 to n.
But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.
Example:
n = 15,
Return: [ &amp;ldquo;1&amp;rdquo;, &amp;ldquo;2&amp;rdquo;, &amp;ldquo;Fizz&amp;rdquo;, &amp;ldquo;4&amp;rdquo;, &amp;ldquo;Buzz&amp;rdquo;, &amp;ldquo;Fizz&amp;rdquo;, &amp;ldquo;7&amp;rdquo;, &amp;ldquo;8&amp;rdquo;, &amp;ldquo;Fizz&amp;rdquo;, &amp;ldquo;Buzz&amp;rdquo;, &amp;ldquo;11&amp;rdquo;, &amp;ldquo;Fizz&amp;rdquo;, &amp;ldquo;13&amp;rdquo;, &amp;ldquo;14&amp;rdquo;, &amp;ldquo;FizzBuzz&amp;rdquo; ]</description>
    </item>
    
    <item>
      <title>414. Third Maximum Number</title>
      <link>https://HauyuChen.github.io/post/414-third-maximum-number/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/414-third-maximum-number/</guid>
      <description>题目描述：  Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).
Example 1: Input: [3, 2, 1] Output: 1
Explanation: The third maximum is 1.
Example 2: Input: [1, 2] Output: 2
Explanation: The third maximum does not exist, so the maximum (2) is returned instead.
Example 3: Input: [2, 2, 3, 1] Output: 1</description>
    </item>
    
    <item>
      <title>415. Add Strings</title>
      <link>https://HauyuChen.github.io/post/415-add-strings/</link>
      <pubDate>Sat, 29 Apr 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/415-add-strings/</guid>
      <description>题目描述：  Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.
Note: The length of both num1 and num2 is &amp;lt; 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly.
 代码实现： class Solution { public: string addStrings(string num1, string num2) { string str; int index1=num1.</description>
    </item>
    
    <item>
      <title>Eclipse常用快捷键</title>
      <link>https://HauyuChen.github.io/post/eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Sat, 01 Apr 2017 17:54:21 +0800</pubDate>
      
      <guid>https://HauyuChen.github.io/post/eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>Hov：本文记录了一些Eclipse快捷键，其中“必记级别”真的很好用，一定要记住~~
必记级别  Ctrl+1：快速修复，代码红色下划线用它就对了
 Ctrl+D：删除当前整行
 Alt+/：代码补全，例如输入syso后按Alt+/，将其补全成System.out.println();
 Ctrl+/：注释代码（这个很重要）
 Shift+Enter：换行（高级模式，可从代码中间跳至下一行，无需到行尾）
 Ctrl+F11：快速运行项目（其实点小三角还是挺快的，不记也行）
  快捷键大全  来源：http://blog.csdn.net/jmyue/article/details/16960199
  Ctrl+Alt+↓：复制当前行到下一行 Ctrl+Alt+↑：复制当前行到上一行 Alt+↓：当前行和下面一行交互位置 Alt+↑：当前行和上面一行交互位置 Alt+←：前一个编辑的页面 Alt+→：下一个编辑的页面 Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性 Shift+Ctrl+Enter 在当前行插入空行 Ctrl+Q 定位到最后编辑的地方 Ctrl+L 定位在某行 Ctrl+M 最大化当前的Edit或View Ctrl+O 快速显示 OutLine Ctrl+T 快速显示当前类的继承结构 Ctrl+W 关闭当前Editer Ctrl+K 参照选中的Word快速定位到下一个 Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示) Ctrl+/ (小键盘) 折叠当前类中的所有代码 Ctrl+×(小键盘) 展开当前类中的所有代码 Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替) Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作) Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这 个功能Idea两年前就有了) Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查) Ctrl+Shift+F4 关闭所有打开的Editer Ctrl+Shift+X 把当前选中的文本全部变味小写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 Ctrl+Shift+F 格式化当前代码 Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力) Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用) Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候) Alt+Shift+F 把Class中的local变量变为field 变量 (比较实用的功能) Alt+Shift+I 合并变量(可能这样说有点不妥Inline) Alt+Shift+V 移动函数和变量(不怎么常用) Alt+Shift+Z 重构的后悔药(Undo)  注：下面这篇文章有动画讲解，推荐一下：）</description>
    </item>
    
    <item>
      <title>136. Single Number</title>
      <link>https://HauyuChen.github.io/post/136-single-number/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/136-single-number/</guid>
      <description> 题目描述：  Given an array of integers, every element appears twice except for one. Find that single one.
Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
 代码实现： class Solution { public: int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ret = 0; for(int num:nums){ ret^=num; } return ret; } };  </description>
    </item>
    
    <item>
      <title>167. Two Sum II - Input array is sorted</title>
      <link>https://HauyuChen.github.io/post/167-two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/167-two-sum-ii-input-array-is-sorted/</guid>
      <description>题目描述：  Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution and you may not use the same element twice.</description>
    </item>
    
    <item>
      <title>169. Majority Element</title>
      <link>https://HauyuChen.github.io/post/169-majority-element/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/169-majority-element/</guid>
      <description> 题目描述：  Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
 代码实现： class Solution { public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int major=nums[0]; int cnt=1; for(int num:nums){ if(num==major){ ++cnt; }else{ --cnt; } if(cnt==0){ ++cnt; major = num; } } return major; } };  </description>
    </item>
    
    <item>
      <title>171. Excel Sheet Column Number</title>
      <link>https://HauyuChen.github.io/post/171-excel-sheet-column-number/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/171-excel-sheet-column-number/</guid>
      <description> 题目描述：  Related to question Excel Sheet Column Title
Given a column title as appear in an Excel sheet, return its corresponding column number.
For example:
A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28   代码实现： class Solution { public: int titleToNumber(string s) { int sum=0; for(int i=0;i&amp;lt;s.length();i++){ sum = sum*26+(s[i]-&#39;A&#39;+1); } return sum; } };  </description>
    </item>
    
    <item>
      <title>191. Number of 1 Bits</title>
      <link>https://HauyuChen.github.io/post/191-number-of-1-bits/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/191-number-of-1-bits/</guid>
      <description> 题目描述：  Write a function that takes an unsigned integer and returns the number of ’1&amp;rsquo; bits it has (also known as the Hamming weight).
For example, the 32-bit integer ’11&amp;rsquo; has binary representation 00000000000000000000000000001011, so the function should return 3.
 代码实现： class Solution { public: int hammingWeight(uint32_t n) { int sum=0; while(n&amp;gt;0){ if(n&amp;amp;1==1){ sum++; } n=n&amp;gt;&amp;gt;1; } return sum; } };  </description>
    </item>
    
    <item>
      <title>206. Reverse Linked List</title>
      <link>https://HauyuChen.github.io/post/206-reverse-linked-list/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/206-reverse-linked-list/</guid>
      <description> 题目描述：  Reverse a singly linked list.
 代码实现： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* pPre=nullptr; ListNode* pNode=head; ListNode* pRet=nullptr; while(pNode!=nullptr){ ListNode* pNext=pNode-&amp;gt;next; if(pNext==nullptr){ pRet=pNode; } pNode-&amp;gt;next=pPre; pPre=pNode; pNode=pNext; } return pRet; } };  </description>
    </item>
    
    <item>
      <title>217. Contains Duplicate</title>
      <link>https://HauyuChen.github.io/post/217-contains-duplicate/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/217-contains-duplicate/</guid>
      <description> 题目描述：  Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
 代码实现： class Solution { public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_set&amp;lt;int&amp;gt; set; for(int num:nums){ if(set.count(num)){ return true; } set.insert(num); } return false; } };  </description>
    </item>
    
    <item>
      <title>226. Invert Binary Tree</title>
      <link>https://HauyuChen.github.io/post/226-invert-binary-tree/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/226-invert-binary-tree/</guid>
      <description>题目描述：  Invert a binary tree.
 4 / \ 2 7 / \ / \ 1 3 6 9 to 4 / \ 7 2 / \ / \ 9 6 3 1  Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</description>
    </item>
    
    <item>
      <title>231. Power of Two</title>
      <link>https://HauyuChen.github.io/post/231-power-of-two/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/231-power-of-two/</guid>
      <description> 题目描述：  Given an integer, write a function to determine if it is a power of two.
 代码实现： class Solution { public: bool isPowerOfTwo(int n) { int flag=0; if(n&amp;lt;=0){ return false; } while(n&amp;gt;0){ if(n&amp;amp;1==1){ if(flag==1){ return false; } flag=1; } n=n&amp;gt;&amp;gt;1; } return true; } };  </description>
    </item>
    
    <item>
      <title>237. Delete Node in a Linked List</title>
      <link>https://HauyuChen.github.io/post/237-delete-node-in-a-linked-list/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/237-delete-node-in-a-linked-list/</guid>
      <description> 题目描述：  Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.
Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.
 代码实现： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { auto next = node-&amp;gt;next; *node = *next; delete next; } };  </description>
    </item>
    
    <item>
      <title>258. Add Digits</title>
      <link>https://HauyuChen.github.io/post/258-add-digits/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/258-add-digits/</guid>
      <description> 题目描述：  Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
For example:
Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.
Follow up: Could you do it without any loop/recursion in O(1) runtime?
 代码实现： class Solution { public: int addDigits(int num) { return 1+(num-1)%9; } };  </description>
    </item>
    
    <item>
      <title>263. Ugly Number</title>
      <link>https://HauyuChen.github.io/post/263-ugly-number/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/263-ugly-number/</guid>
      <description>题目描述：  Write a program to check whether a given number is an ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.
Note that 1 is typically treated as an ugly number.
 代码实现： class Solution { public: bool isUgly(int num) { if(num&amp;lt;=0){ return false; } while(num%2==0){ num/=2; } while(num%3==0){ num/=3; } while(num%5==0){ num/=5; } return num==1?</description>
    </item>
    
    <item>
      <title>268. Missing Number</title>
      <link>https://HauyuChen.github.io/post/268-missing-number/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/268-missing-number/</guid>
      <description>题目描述：  Given an array containing n distinct numbers taken from 0, 1, 2, &amp;hellip;, n, find the one that is missing from the array.
For example, Given nums = [0, 1, 3] return 2.
Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
 代码实现： class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int sum=0; int realsum=0; bool flag=false; for(int i=0;i&amp;lt;nums.</description>
    </item>
    
    <item>
      <title>283. Move Zeroes</title>
      <link>https://HauyuChen.github.io/post/283-move-zeroes/</link>
      <pubDate>Wed, 29 Mar 2017 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/283-move-zeroes/</guid>
      <description>题目描述：  Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
Note: You must do this in-place without making a copy of the array. Minimize the total number of operations.
 代码实现： class Solution { public: void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int index=0; for(int i=0;i&amp;lt;nums.</description>
    </item>
    
    <item>
      <title>242. Valid Anagram</title>
      <link>https://HauyuChen.github.io/post/242-valid-anagram/</link>
      <pubDate>Tue, 21 Mar 2017 20:54:45 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/242-valid-anagram/</guid>
      <description>题目描述：  Given two strings s and t, write a function to determine if t is an anagram of s.
For example, s = &amp;ldquo;anagram&amp;rdquo;, t = &amp;ldquo;nagaram&amp;rdquo;, return true. s = &amp;ldquo;rat&amp;rdquo;, t = &amp;ldquo;car&amp;rdquo;, return false.
Note: You may assume the string contains only lowercase alphabets.
Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?
 代码实现： class Solution { public: bool isAnagram(string s, string t) { if(s.</description>
    </item>
    
    <item>
      <title>1. Two Sum</title>
      <link>https://HauyuChen.github.io/post/001-two-sum/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/001-two-sum/</guid>
      <description>题目描述：  Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example: Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].
 我的思路：   先用map存储每个元素对应的原始下标，方便后续查找特定元素。 从头开始查找符合条件的结果，用target减去nums[i]，得到两数之差t，在map中寻找是否存在t且元素t的索引不等于i,若是则为最终结果，否则继续查找nums[i+1]。   代码实现： class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { unordered_map&amp;lt;int,int&amp;gt; hm; for(int i=0;i&amp;lt;nums.</description>
    </item>
    
    <item>
      <title>100. Same Tree</title>
      <link>https://HauyuChen.github.io/post/100-same-tree/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/100-same-tree/</guid>
      <description>题目描述：  Given two binary trees, write a function to check if they are equal or not.
Two binary trees are considered equal if they are structurally identical and the nodes have the same value.
 代码实现： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p==nullptr &amp;amp;&amp;amp; q==nullptr){ return true; } else if(p==nullptr || q==nullptr){ return false; } if(p-&amp;gt;val!</description>
    </item>
    
    <item>
      <title>104. Maximum Depth of Binary Tree</title>
      <link>https://HauyuChen.github.io/post/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/104-maximum-depth-of-binary-tree/</guid>
      <description>题目描述：  Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
 代码实现： /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int maxDepth(TreeNode *root) { int Ldepth=0,Rdepth=0; if(root==NULL){ return 0; } if(root-&amp;gt;left==NULL &amp;amp;&amp;amp; root-&amp;gt;right==NULL){ return 1; } Ldepth=maxDepth(root-&amp;gt;left); Rdepth=maxDepth(root-&amp;gt;right); return 1+(Ldepth&amp;gt;Rdepth?</description>
    </item>
    
    <item>
      <title>121. Best Time to Buy and Sell Stock</title>
      <link>https://HauyuChen.github.io/post/121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/121-best-time-to-buy-and-sell-stock/</guid>
      <description>题目描述：  Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5
max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: Input: [7, 6, 4, 3, 1] Output: 0</description>
    </item>
    
    <item>
      <title>122. Best Time to Buy and Sell Stock II</title>
      <link>https://HauyuChen.github.io/post/122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>题目描述：  Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>13. Roman to Integer</title>
      <link>https://HauyuChen.github.io/post/013-roman-to-integer/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/013-roman-to-integer/</guid>
      <description> 题目描述：  Given a roman numeral, convert it to an integer.
Input is guaranteed to be within the range from 1 to 3999.
 我的思路：  这是一道将罗马数字转换成整数的题目。搞清楚罗马数字的表示特点即可。
参见维基百科：罗马数字
 代码实现： class Solution { public: int romanToInt(string s) { unordered_map&amp;lt;char,int&amp;gt; hm; hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;I&#39;,1)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;V&#39;,5)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;X&#39;,10)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;L&#39;,50)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;C&#39;,100)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;D&#39;,500)); hm.insert(pair&amp;lt;char,int&amp;gt;(&#39;M&#39;,1000)); int sum=hm[s[s.size()-1]]; for(int i=s.size()-1;i&amp;gt;0;--i){ if(hm[s[i]]&amp;gt;hm[s[i-1]]){ sum-=hm[s[i-1]]; }else{ sum+=hm[s[i-1]]; } } return sum; } };  </description>
    </item>
    
    <item>
      <title>21. Merge Two Sorted Lists</title>
      <link>https://HauyuChen.github.io/post/021-merge-two-sorted-lists/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/021-merge-two-sorted-lists/</guid>
      <description>题目描述：  Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
 我的思路：   通过一个指针newhead指示新的链表头部，比较链表l1和链表l2的第一个结点。 若l1的第一个节点比l2小，则将其尾插进新链表，移动指针l1-&amp;gt;next；若l2的第一个节点比l1小，同理。 递归得解。   代码实现： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1==nullptr&amp;amp;&amp;amp;l2==nullptr) return nullptr; if(l1==nullptr || l2==nullptr) return (l1==nullptr)?</description>
    </item>
    
    <item>
      <title>53. Maximum Subarray</title>
      <link>https://HauyuChen.github.io/post/053-maximum-subarray/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/053-maximum-subarray/</guid>
      <description> 题目描述：  Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6.
 我的思路：  用sum保存连续序列之和，用max表示最大值，一次遍历即可，时间复杂度O(n)。
 sum&amp;lt;0,则舍弃前面的数 sum&amp;gt;max,则更新最大值max   代码实现： int maxSubArray(int* nums, int numsSize) { int sum=0; int max=INT_MIN; for(int i=0;i&amp;lt;numsSize;i++){ sum+=nums[i]; if(sum&amp;gt;max){ max = sum; } if(sum&amp;lt;0){ sum = 0; } } return max; }  </description>
    </item>
    
    <item>
      <title>69. Sqrt(x)</title>
      <link>https://HauyuChen.github.io/post/069-sqrtx/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/069-sqrtx/</guid>
      <description> 题目描述：  Implement int sqrt(int x).
Compute and return the square root of x.
 代码实现： class Solution { public: int mySqrt(int x) { if(x==0){ return 0; } int low=1,high=x; int mid; while(1){ mid = (low+high)/2; if(mid&amp;gt;x/mid){ high = mid-1; } else{ if((mid+1)&amp;gt;(x/(mid+1))){ return mid; } low = mid+1; } } } };  </description>
    </item>
    
    <item>
      <title>70. Climbing Stairs</title>
      <link>https://HauyuChen.github.io/post/070-climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/070-climbing-stairs/</guid>
      <description> 题目描述：  You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
 思路：  这题本质上是斐波那契数列问题。这里采用数组暂存已有结果，以时间换空间，减少递归带来的重复计算。
 代码实现： class Solution { public: int climbStairs(int n) { int f[n+1]; f[0]=1; f[1]=1; for(int i=2;i&amp;lt;=n;++i){ f[i]=f[i-1]+f[i-2]; } return f[n]; } };  </description>
    </item>
    
    <item>
      <title>8. String to Integer (atoi)</title>
      <link>https://HauyuChen.github.io/post/008-string-to-integeratoi/</link>
      <pubDate>Thu, 29 Sep 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/008-string-to-integeratoi/</guid>
      <description>题目描述：  Implement atoi to convert a string to an integer.
Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.
Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.
Update (2015-02-10): The signature of the C++ function had been updated.</description>
    </item>
    
    <item>
      <title>202. Happy Number</title>
      <link>https://HauyuChen.github.io/post/202-happy-number/</link>
      <pubDate>Mon, 29 Aug 2016 17:54:21 +0100</pubDate>
      
      <guid>https://HauyuChen.github.io/post/202-happy-number/</guid>
      <description>题目描述：  Write an algorithm to determine if a number is &amp;ldquo;happy&amp;rdquo;.
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
  </channel>
</rss>