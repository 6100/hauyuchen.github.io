<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Hov&#39;s Blog</title>
    <link>https://HauyuChen.github.io/topics/java/</link>
    <description>Recent content in Java on Hov&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Wed, 20 Dec 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://HauyuChen.github.io/topics/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>谈谈向上转型、向下转型</title>
      <link>https://HauyuChen.github.io/post/java_-polymorphism_1/</link>
      <pubDate>Wed, 20 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java_-polymorphism_1/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>重写、重载的区别</title>
      <link>https://HauyuChen.github.io/post/java_overload_override/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java_overload_override/</guid>
      <description>0 写在前面 重写和重载是面向对象程序设计中十分重要的两个概念，其中重写又称为覆盖。 通俗的理解就是，重写就是将一个方法的实现过程再写一遍，覆盖原</description>
    </item>
    
    <item>
      <title>【设计模式】4. 观察者模式</title>
      <link>https://HauyuChen.github.io/post/dp_observer_pattern/</link>
      <pubDate>Fri, 17 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/dp_observer_pattern/</guid>
      <description>版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。 1 观察者模式 1.1 简介 观察者模式是对象之间实现多对一依赖的一种设计方案，其可让多个观察者同时监</description>
    </item>
    
    <item>
      <title>抽象类与接口的区别</title>
      <link>https://HauyuChen.github.io/post/java_abstractclass_interface/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java_abstractclass_interface/</guid>
      <description>0 写在前面 抽象类和接口有共同点，也有不同点。在实际应用中，我们有时会不知道什么时候用抽象类，什么时候用接口。因此，我们有必要了解抽象类和接口</description>
    </item>
    
    <item>
      <title>Java关键字this、super、static、final</title>
      <link>https://HauyuChen.github.io/post/java_thissuperstaticfinal/</link>
      <pubDate>Wed, 25 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java_thissuperstaticfinal/</guid>
      <description>0 写在前面 本文主要讲讲 Java 中比较常见的关键字，如 this 、 super 、 static 、 final ，它们在程序中出现频率较高。 1 this 表示类中的属性，比如 this.username = username; 强调调用的是本类的方法</description>
    </item>
    
    <item>
      <title>JSON相关操作（Java）</title>
      <link>https://HauyuChen.github.io/post/java_json/</link>
      <pubDate>Wed, 11 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java_json/</guid>
      <description>1 Java中创建JSON import com.google.gson.JsonArray; import com.google.gson.JsonObject; public class CreateJSON { public static void main(String[] args) { JsonObject object = new JsonObject(); object.addProperty(&amp;quot;cat&amp;quot;, &amp;quot;it&amp;quot;); JsonArray array = new JsonArray(); JsonObject lan1 = new JsonObject(); lan1.addProperty(&amp;quot;id&amp;quot;, 1); lan1.addProperty(&amp;quot;name&amp;quot;, &amp;quot;Java&amp;quot;); lan1.addProperty(&amp;quot;ide&amp;quot;, &amp;quot;Eclipse&amp;quot;); array.add(lan1); JsonObject lan2 = new JsonObject(); lan2.addProperty(&amp;quot;id&amp;quot;, 2); lan2.addProperty(&amp;quot;name&amp;quot;, &amp;quot;Swift&amp;quot;); lan2.addProperty(&amp;quot;ide&amp;quot;, &amp;quot;XCode&amp;quot;); array.add(lan2); JsonObject lan3 = new JsonObject(); lan3.addProperty(&amp;quot;id&amp;quot;, 3); lan3.addProperty(&amp;quot;name&amp;quot;,</description>
    </item>
    
    <item>
      <title>XML相关操作（Java）</title>
      <link>https://HauyuChen.github.io/post/java_xml/</link>
      <pubDate>Wed, 11 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java_xml/</guid>
      <description>1 XML文件创建示例 import java.io.File; import java.io.StringWriter; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import org.w3c.dom.Document; import org.w3c.dom.Element; public class CreateXML { public static void main(String[] args) { try { //DOM DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); Document document = builder.newDocument(); //创建Langu</description>
    </item>
    
    <item>
      <title>谈谈 Java IO</title>
      <link>https://HauyuChen.github.io/post/java_io/</link>
      <pubDate>Thu, 05 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java_io/</guid>
      <description>版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。 0 写在前面 IO 操作是任何编程语言都无法回避的问题，因为 IO 操作是机器获取和交换信息的主要途径。</description>
    </item>
    
    <item>
      <title>【设计模式】3. 装饰者模式</title>
      <link>https://HauyuChen.github.io/post/dp_decorator_pattern/</link>
      <pubDate>Fri, 29 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/dp_decorator_pattern/</guid>
      <description>版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。 1 装饰者模式 1.1 简介 装饰者模式可动态地向对象添加额外的属性或行为。装饰者模式是类继承的另外一</description>
    </item>
    
    <item>
      <title>String相关特性</title>
      <link>https://HauyuChen.github.io/post/java_string/</link>
      <pubDate>Thu, 14 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java_string/</guid>
      <description>1 字符串实例化两种方式的区别 String 的实例化方式有两种，一种是直接赋值，另一种是通过 new 关键字实例化字符串。 1.1 直接赋值 String str1 = &amp;quot;hello&amp;quot;; 使用直接赋值方式，只要</description>
    </item>
    
    <item>
      <title>Java 进程通信（共享内存）</title>
      <link>https://HauyuChen.github.io/post/java_ipc/</link>
      <pubDate>Wed, 06 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java_ipc/</guid>
      <description>0 写在前面 说到进程通信，我们很轻易就能想到经典的 Socket 通信。但像 Socket 这样的网络通信会增加额外的网络负担，同时也增加了一定的代码量。 共享内存方式是实</description>
    </item>
    
    <item>
      <title>【设计模式】2. 策略模式</title>
      <link>https://HauyuChen.github.io/post/dp_strategy_pattern/</link>
      <pubDate>Sat, 19 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/dp_strategy_pattern/</guid>
      <description>版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。 1 策略模式 1.1 简介 策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为</description>
    </item>
    
    <item>
      <title>【设计模式】1. 单例模式</title>
      <link>https://HauyuChen.github.io/post/dp_singleton_pattern/</link>
      <pubDate>Thu, 17 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/dp_singleton_pattern/</guid>
      <description>版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。 1 单例模式 1.1 简介 单例模式是一种基本的常用的软件设计模式。单例模式的核心是确保一个类最多只有</description>
    </item>
    
    <item>
      <title>Java相关特性</title>
      <link>https://HauyuChen.github.io/post/java_trap/</link>
      <pubDate>Tue, 08 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java_trap/</guid>
      <description>Java备忘 float 和 double 不能进行精确运算，因为计算机不能表示所有的小数，采用 BigDecimal 来解决（String）。 switch 语句不能作用在 long 和 String 上。 true 、 false 、 null 不是严格</description>
    </item>
    
  </channel>
</rss>