<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Hov&#39;s Blog</title>
    <link>https://HauyuChen.github.io/topics/java/</link>
    <description>Recent content in Java on Hov&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Sat, 19 Aug 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://HauyuChen.github.io/topics/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【设计模式】2.策略模式</title>
      <link>https://HauyuChen.github.io/post/dp-2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 19 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/dp-2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。

1 策略模式 1.1 简介 策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。
比如，买东西要付款，但是付款的方式有多种，比如有的人现金支付，有的人网上支付，有的人找人代付。
1.2 思路 策略模式将每一个算法封装起来，实现算法族（业务规则），这些算法可互换代替。
策略模式通过分离变化部分，封装接口，基于接口实现不同的功能。也就是说，对于同一类型的操作，将复杂多样的处理方式分离开来，有选择的实现各自特有的操作。通常，在超类放行为接口对象，在子类设定具体行为对象。
1.3 使用场景  对于同一类型问题的多种处理方式，仅仅具体行为有差别。 需要安全的封装多种同一类型的操作。 出现同一抽象多个子类，又需要使用if或switch选择语句来选择。  1.4 优缺点 优点：
 算法可自由切换； 避免使用多重条件判断； 扩展性良好。 可替换继承关系  缺点：
 策略类会增多； 所有策略类都需要对外暴露。  
2 实例讲解 我们引入模拟鸭子这个栗子（这是极客学院中讲解的栗子，个人觉得简单易懂，推荐）。
2.1 原始需求 我们通过程序模拟鸭子，假设我们的需求是这样的：鸭子有绿头鸭和红头鸭两种，它们都会嘎嘎叫和游泳。
根据需求，借助面向对象思维，我们可以设计如下代码：
（1）首先设计一个抽象类：鸭子
/* Duck.java */ public abstract class Duck{ public Duck(){ } public abstract void display(); //外观 public void Quack(){ //嘎嘎叫 System.out.println(&amp;quot;--gaga--&amp;quot;); } public void swim(){ //游泳 System.</description>
    </item>
    
    <item>
      <title>【设计模式】1.单例模式</title>
      <link>https://HauyuChen.github.io/post/dp-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 17 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/dp-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>版权声明：本文由 Hov 所有，发布于 http://chenhy.com ，转载请注明出处。

1 单例模式 1.1 简介 单例模式是一种基本的常用的软件设计模式。单例模式的核心是确保一个类最多只有一个实例，并提供一个全局访问点。
1.2 思路 一个类只能返回对象的一个引用（始终为同一个）和一个获得此实例的方法（静态方法，通常用 getInstance 命名）。当我们调用 getInstance 方法，如果类保持的引用不为空，则返回此引用；如果类保持的引用为空，则创建该类的实例，并将实例的引用赋予该类保持的引用。 同时，我们还将该类的构造函数定义为私有方法，这样其它地方的代码就无法通过该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法得到该类的唯一实例。
1.3 使用场景  需要频繁实例化然后销毁的对象； 创建对象时耗时过多或耗费资源过多，但又经常用到的对象； 有状态的工具类对象； 频繁访问数据库或文件的对象；  1.4 优缺点 优点：
 在内存中只有一个对象，节省内存空间； 避免频繁创建销毁对象，可提高性能； 避免对共享资源的多重占用； 可以全局访问。  缺点：
 多线程情况下，应注意线程安全问题； 只能通过单例类提供的方法创建单例对象，不能使用反射；  
2 经典实现 这是最简单的最经典的单例模式实现方式，又称为懒汉式（线程不安全）。由于该方式存在不少弊端，通常不采用。但是，我们还是有必要了解，因为它是后面几个优化方式的基础。
注：
 懒汉式：指全局的单例实例在第一次使用时被构建； 饿汉式：指全局的单例实例在类装载时就被构建。  /* Singleton.java */ public class Singleton { private static Singleton uniqeInstance = null; private Singleton() { }; public static Singleton getInstance() { if(uniqeInstance == null) { uniqeInstance = new Singleton(); } return uniqeInstance; } }</description>
    </item>
    
    <item>
      <title>Java相关特性</title>
      <link>https://HauyuChen.github.io/post/java-trap/</link>
      <pubDate>Tue, 08 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java-trap/</guid>
      <description>Java备忘  float 和 double 不能进行精确运算，因为计算机不能表示所有的小数，采用 BigDecimal 来解决（String）。
 switch 语句不能作用在 long 和 String 上。
 true 、 false 、 null 不是严格意义上的关键字，而是文字常量（literals）。
 float f = 2.5；不正确，因为精度不准确。正确写法：float f = (float)2.5;
 try｛ ｝里面的 return 语句，紧跟着 finally｛ ｝里的代码会在 return 前先执行。</description>
    </item>
    
    <item>
      <title>JSON相关操作（Java）</title>
      <link>https://HauyuChen.github.io/post/java-json/</link>
      <pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java-json/</guid>
      <description>1 Java中创建JSON import com.google.gson.JsonArray; import com.google.gson.JsonObject; public class CreateJSON { public static void main(String[] args) { JsonObject object = new JsonObject(); object.addProperty(&amp;quot;cat&amp;quot;, &amp;quot;it&amp;quot;); JsonArray array = new JsonArray(); JsonObject lan1 = new JsonObject(); lan1.addProperty(&amp;quot;id&amp;quot;, 1); lan1.addProperty(&amp;quot;name&amp;quot;, &amp;quot;Java&amp;quot;); lan1.addProperty(&amp;quot;ide&amp;quot;, &amp;quot;Eclipse&amp;quot;); array.add(lan1); JsonObject lan2 = new JsonObject(); lan2.addProperty(&amp;quot;id&amp;quot;, 2); lan2.addProperty(&amp;quot;name&amp;quot;, &amp;quot;Swift&amp;quot;); lan2.addProperty(&amp;quot;ide&amp;quot;, &amp;quot;XCode&amp;quot;); array.add(lan2); JsonObject lan3 = new JsonObject(); lan3.addProperty(&amp;quot;id&amp;quot;, 3); lan3.addProperty(&amp;quot;name&amp;quot;, &amp;quot;C#&amp;quot;); lan3.addProperty(&amp;quot;ide&amp;quot;, &amp;quot;Visual Studio&amp;quot;); array.add(lan3); object.add(&amp;quot;languages&amp;quot;, array); object.addProperty(&amp;quot;pop&amp;quot;, true); System.</description>
    </item>
    
    <item>
      <title>XML相关操作（Java）</title>
      <link>https://HauyuChen.github.io/post/java-xml/</link>
      <pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java-xml/</guid>
      <description>1 XML文件创建示例 import java.io.File; import java.io.StringWriter; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import org.w3c.dom.Document; import org.w3c.dom.Element; public class CreateXML { public static void main(String[] args) { try { //DOM DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); Document document = builder.newDocument(); //创建Languages标签 Element root = document.createElement(&amp;quot;Languages&amp;quot;); root.setAttribute(&amp;quot;cat&amp;quot;, &amp;quot;it&amp;quot;); //设置Languages标签的属性 //-----接下来创建Languages标签下的三个子标签lan1、lan2、lan3 //lan1 Element lan1 = document.createElement(&amp;quot;lan&amp;quot;); //lan标签 lan1.setAttribute(&amp;quot;id&amp;quot;, &amp;quot;1&amp;quot;); Element name1 = document.</description>
    </item>
    
    <item>
      <title>String相关特性（不定时更新）</title>
      <link>https://HauyuChen.github.io/post/java-string/</link>
      <pubDate>Tue, 18 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://HauyuChen.github.io/post/java-string/</guid>
      <description>声明：本文是我对Java中String的特性的一些笔记，描述较为简练，有误之处还望指正。
 1.字符串实例化两种方式的区别 String的实例化方式有两种，一种是直接赋值，另一种是通过new关键字实例化。
（1）直接赋值
String str1 = &amp;quot;hello&amp;quot;;  （2）new关键字
String str2 = new String(&amp;quot;hello&amp;quot;);  两种方式都能实例化新的字符串，那我们用哪种方式比较好呢？ 这要先弄清楚他们之间的区别。
 str1是通过直接赋值，str1将直接指向一个存放“hello”的内存空间，因此至占用一个内存空间。 str2是通过new关键字实例化，通过new关键字将开辟一个新的内存空间，赋值后将开辟一个新的内存空间存放str2，也就是说使用new关键字实例化字符串总共开辟了两个内存空间。  综上，使用直接赋值的方法较好，毕竟可以避免占用多余的内存空间。

2.字符串比较“==”与equals的区别 字符串比较是较为常用的功能，Java中主要提供了两种字符串比较方式，“==”和equals，如下：
String str1 = &amp;quot;hello&amp;quot;; String str2 = new String(&amp;quot;hello&amp;quot;); System.out.println(str1==str2); //false System.out.println(str1.equals(str2)); //true  奇怪，明明str1和str2是一样的，为什么“==”会是false呢？
这是因为，“==”比较的是内存单元地址，equals比较的是内容。由前一小节可知，new关键字实例化方式会开辟两个内存空间，str1和str2虽然都是hello，但他们存放的内存空间是不一样的。

3.String内容不可变 假设：
String str = &amp;quot;hello&amp;quot;; str = str + &amp;quot;world!&amp;quot;;  分析：原先str指向的是存放“hello”的内存空间，经过重新赋值，并不会将内存空间的“hello”改成“helloworld!”,而是开辟了新的内存空间存放“helloworld!”，将str重新指向存放“helloworld!”的内存空间。</description>
    </item>
    
  </channel>
</rss>